# 血战到底麻将前端技术栈选型文档

## 文档版本
- **版本号**: v1.0
- **创建日期**: 2025-11-05
- **最后更新**: 2025-11-05

---

## 1. 技术栈概览

### 1.1 完整技术栈
```yaml
核心框架:
  语言: TypeScript 5.x
  框架: React 18.2+
  构建工具: Vite 5.x

状态管理:
  全局状态: Zustand 4.x
  服务器状态: TanStack Query (React Query) 5.x

渲染引擎:
  2D渲染: HTML5 Canvas API
  图片资源: 精灵图 (Sprite Sheet)

网络通信:
  HTTP客户端: Axios 1.x
  通信协议: RESTful API

UI框架:
  样式方案: Tailwind CSS 3.x
  组件库: shadcn/ui (可选) / 自定义组件
  图标: Lucide React

开发工具链:
  代码质量: ESLint + Prettier
  类型检查: TypeScript Strict Mode
  包管理器: npm / pnpm
```

---

## 2. 核心技术选型理由

### 2.1 TypeScript

#### 选择理由
- ✅ **类型安全**：游戏逻辑复杂，类型约束减少运行时错误
- ✅ **前后端类型共享**：可导出后端API的类型定义，确保契约一致
- ✅ **IDE支持好**：自动补全、重构工具，提升开发效率
- ✅ **主流趋势**：2024-2025前端标配，生态成熟

#### 版本选择
- **TypeScript 5.x**：最新稳定版，性能优化、类型推导更强大

#### 配置建议
```json
{
  "compilerOptions": {
    "target": "ES2020",
    "strict": true,
    "noUncheckedIndexedAccess": true,
    "exactOptionalPropertyTypes": true
  }
}
```

---

### 2.2 React 18

#### 选择理由
- ✅ **生态最成熟**：组件库、工具链、教程最丰富
- ✅ **声明式UI**：适合复杂状态驱动的游戏界面
- ✅ **Hooks强大**：`useState`、`useEffect`、`useRef` 完美适配游戏逻辑
- ✅ **虚拟DOM优化**：状态变更时高效更新UI
- ✅ **团队熟悉度高**：招聘、维护成本低

#### 版本选择
- **React 18.2+**：支持并发渲染（Concurrent Features），为未来优化预留空间

#### 对比其他框架
| 框架 | 优势 | 劣势 | 适用场景 |
|------|------|------|----------|
| **React** | 生态最强、资源多 | 相对冗余（需配套工具） | 复杂应用、团队协作 |
| Vue 3 | API简洁、响应式强 | 游戏案例少 | 快速开发 |
| Svelte | 性能极致、无虚拟DOM | 生态较小、招聘难 | 小型项目 |

**结论**：本项目选择 **React**，平衡生态、性能、可维护性。

---

### 2.3 Vite

#### 选择理由
- ✅ **极速启动**：基于ES Module，开发服务器秒启动
- ✅ **HMR闪电快**：热更新比Webpack快10倍+
- ✅ **开箱即用**：原生支持TypeScript、JSX、CSS Modules
- ✅ **构建优化**：使用Rollup打包，体积小、Tree Shaking强
- ✅ **2024-2025主流**：已取代Create React App，成为React官方推荐

#### 配置示例
```typescript
// vite.config.ts
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

export default defineConfig({
  plugins: [react()],
  server: {
    port: 5173,
    proxy: {
      '/api': 'http://localhost:8000'  // 代理后端API
    }
  },
  build: {
    target: 'es2020',
    outDir: 'dist'
  }
})
```

---

### 2.4 Zustand（状态管理）

#### 选择理由
- ✅ **轻量简单**：核心代码仅1KB，API极简
- ✅ **无模板代码**：不像Redux需要actions/reducers
- ✅ **TypeScript友好**：类型推导完美
- ✅ **性能优秀**：基于Hooks，按需订阅，无不必要渲染
- ✅ **适合游戏**：全局状态管理（玩家手牌、游戏阶段、操作历史）

#### 示例代码
```typescript
// stores/gameStore.ts
import { create } from 'zustand'

interface GameState {
  gameId: string | null
  phase: 'INIT' | 'BURYING' | 'PLAYING' | 'ENDED'
  playerHand: Tile[]
  currentPlayer: number

  // Actions
  setGameId: (id: string) => void
  updatePhase: (phase: string) => void
  setPlayerHand: (tiles: Tile[]) => void
}

export const useGameStore = create<GameState>((set) => ({
  gameId: null,
  phase: 'INIT',
  playerHand: [],
  currentPlayer: 0,

  setGameId: (id) => set({ gameId: id }),
  updatePhase: (phase) => set({ phase }),
  setPlayerHand: (tiles) => set({ playerHand: tiles })
}))
```

#### 对比其他方案
| 方案 | 优势 | 劣势 |
|------|------|------|
| **Zustand** | 简单、轻量 | 生态工具少 |
| Redux Toolkit | 生态强大、DevTools | 模板代码多 |
| Jotai/Recoil | 原子化状态 | 学习成本高 |
| Context API | 原生无依赖 | 性能差、无DevTools |

**结论**：本项目选择 **Zustand**，简单够用。

---

### 2.5 TanStack Query（服务器状态）

#### 选择理由
- ✅ **专注服务器状态**：缓存、轮询、重试、失效自动处理
- ✅ **轮询支持完美**：本项目需要轮询游戏状态，Query自带 `refetchInterval`
- ✅ **减少模板代码**：无需手写loading/error状态管理
- ✅ **DevTools强大**：可视化查询状态、缓存

#### 示例代码
```typescript
// hooks/useGameState.ts
import { useQuery } from '@tanstack/react-query'
import { gameApi } from '@/services/api'

export function useGameState(gameId: string) {
  return useQuery({
    queryKey: ['gameState', gameId],
    queryFn: () => gameApi.getGameState(gameId),
    refetchInterval: 500,  // 每500ms轮询一次
    enabled: !!gameId,
    staleTime: 0  // 始终认为数据过期，保证实时性
  })
}
```

#### 为什么不用SWR？
- TanStack Query功能更全（mutation、infinite query）
- 文档更完善，TypeScript支持更好

---

### 2.6 Canvas渲染

#### 选择理由
- ✅ **性能高**：直接操作像素，适合大量图形渲染
- ✅ **灵活性强**：完全控制麻将牌的绘制、动画、交互
- ✅ **无依赖**：浏览器原生API，无需第三方库
- ✅ **麻将牌适配性好**：固定尺寸、静态图片，Canvas完美适配

#### 对比其他方案
| 方案 | 优势 | 劣势 | 适用场景 |
|------|------|------|----------|
| **Canvas** | 性能高、灵活 | 代码量大 | 自定义渲染 |
| SVG | 矢量、可交互 | 大量元素性能差 | 图表、地图 |
| Pixi.js | 2D引擎、精灵动画 | 包体积大（400KB+） | 复杂游戏 |
| Three.js | 3D效果 | 学习成本高、体积大 | 3D游戏 |

**结论**：本项目选择 **原生Canvas**，MVP阶段足够用。

#### 性能优化策略
```typescript
// 1. 离屏Canvas缓存麻将牌
const offscreenCanvas = document.createElement('canvas')
const offscreenCtx = offscreenCanvas.getContext('2d')!
// 预绘制所有牌面到离屏Canvas

// 2. 分层Canvas
<div className="game-board">
  <canvas id="bg-layer" />      {/* 静态背景 */}
  <canvas id="tiles-layer" />   {/* 麻将牌 */}
  <canvas id="ui-layer" />      {/* 操作提示 */}
</div>

// 3. 只重绘变化区域
ctx.clearRect(x, y, width, height)  // 清除局部区域
ctx.drawImage(tileImage, x, y)      // 重绘单张牌
```

---

### 2.7 Axios（HTTP客户端）

#### 选择理由
- ✅ **功能完善**：拦截器、超时、取消请求
- ✅ **错误处理好**：统一处理HTTP错误
- ✅ **TypeScript支持**：泛型定义响应类型
- ✅ **浏览器兼容性好**：自动polyfill

#### 配置示例
```typescript
// services/apiClient.ts
import axios from 'axios'

export const apiClient = axios.create({
  baseURL: import.meta.env.VITE_API_BASE_URL || 'http://localhost:8000',
  timeout: 10000,
  headers: {
    'Content-Type': 'application/json'
  }
})

// 请求拦截器
apiClient.interceptors.request.use((config) => {
  // 添加游戏ID到header（如需要）
  return config
})

// 响应拦截器
apiClient.interceptors.response.use(
  (response) => response.data,
  (error) => {
    console.error('API Error:', error)
    return Promise.reject(error)
  }
)
```

---

### 2.8 Tailwind CSS（样式方案）

#### 选择理由
- ✅ **开发效率高**：原子类快速布局，无需写CSS文件
- ✅ **体积小**：按需生成，生产环境只包含用到的类
- ✅ **响应式友好**：`md:` `lg:` 断点轻松实现
- ✅ **主题一致性**：颜色、间距、字体统一管理
- ✅ **与React完美配合**：className驱动，无CSS-in-JS性能问题

#### 配置示例
```typescript
// tailwind.config.js
export default {
  content: ['./index.html', './src/**/*.{js,ts,jsx,tsx}'],
  theme: {
    extend: {
      colors: {
        'mahjong-green': '#1a5f3f',
        'tile-face': '#f5f5dc'
      }
    }
  }
}
```

#### 对比其他方案
| 方案 | 优势 | 劣势 |
|------|------|------|
| **Tailwind CSS** | 快速、体积小 | HTML冗长 |
| CSS Modules | 作用域隔离 | 需写CSS文件 |
| Styled Components | CSS-in-JS、动态 | 性能开销大 |

---

## 3. 辅助技术选型

### 3.1 shadcn/ui（可选）

#### 作用
提供预制UI组件（按钮、对话框、Toast提示）

#### 选择理由
- ✅ **非npm包**：直接复制代码到项目，可自定义
- ✅ **基于Radix UI**：无障碍访问（a11y）支持好
- ✅ **Tailwind驱动**：样式统一

#### MVP阶段建议
- 暂不使用，手写简单组件即可
- 后期优化UI时再引入

---

### 3.2 Lucide React（图标）

#### 选择理由
- ✅ **轻量**：按需导入，Tree Shaking友好
- ✅ **图标全**：1000+图标，覆盖常用场景
- ✅ **React优化**：组件化，支持props

#### 使用示例
```tsx
import { PlayIcon, RefreshCwIcon } from 'lucide-react'

<button>
  <PlayIcon size={20} /> 开始游戏
</button>
```

---

### 3.3 clsx / cn（类名工具）

#### 作用
条件拼接className

#### 使用示例
```typescript
import clsx from 'clsx'

const tileClass = clsx(
  'tile',
  isSelected && 'tile-selected',
  isDisabled && 'tile-disabled'
)
```

---

## 4. 开发工具链

### 4.1 ESLint + Prettier

#### 配置建议
```json
// .eslintrc.json
{
  "extends": [
    "eslint:recommended",
    "plugin:@typescript-eslint/recommended",
    "plugin:react/recommended",
    "plugin:react-hooks/recommended",
    "prettier"
  ],
  "rules": {
    "react/react-in-jsx-scope": "off"  // React 18+不需要
  }
}
```

```json
// .prettierrc
{
  "semi": false,
  "singleQuote": true,
  "tabWidth": 2,
  "printWidth": 100
}
```

---

### 4.2 TypeScript配置

```json
// tsconfig.json
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "ESNext",
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "jsx": "react-jsx",
    "strict": true,
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "esModuleInterop": true,
    "noUncheckedIndexedAccess": true,
    "skipLibCheck": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"]
    }
  },
  "include": ["src"],
  "references": [{ "path": "./tsconfig.node.json" }]
}
```

---

### 4.3 包管理器

#### 推荐：pnpm
- ✅ 速度快、节省磁盘空间
- ✅ Monorepo支持好（未来前后端合并仓库）
- ✅ 2024主流趋势

#### 备选：npm
- ✅ Node.js自带，无需安装

---

## 5. 项目依赖清单

### 5.1 核心依赖
```json
{
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "zustand": "^4.5.0",
    "@tanstack/react-query": "^5.17.0",
    "axios": "^1.6.5",
    "clsx": "^2.1.0",
    "lucide-react": "^0.314.0"
  },
  "devDependencies": {
    "@vitejs/plugin-react": "^4.2.1",
    "vite": "^5.0.12",
    "typescript": "^5.3.3",
    "@types/react": "^18.2.48",
    "@types/react-dom": "^18.2.18",
    "eslint": "^8.56.0",
    "prettier": "^3.2.4",
    "tailwindcss": "^3.4.1"
  }
}
```

---

## 6. 技术栈优势总结

### 6.1 开发效率
- ✅ **Vite秒启动**，HMR极速，开发体验流畅
- ✅ **TypeScript类型提示**，减少调试时间
- ✅ **Zustand简单**，状态管理无心智负担
- ✅ **Tailwind快速布局**，无需写CSS文件

### 6.2 性能表现
- ✅ **Canvas高性能渲染**，60fps流畅
- ✅ **Vite Tree Shaking**，生产包体积小
- ✅ **React 18并发特性**，未来可优化
- ✅ **TanStack Query缓存**，减少API请求

### 6.3 可维护性
- ✅ **TypeScript类型安全**，重构无风险
- ✅ **前后端类型共享**，API契约清晰
- ✅ **组件化架构**，代码复用性高
- ✅ **主流技术栈**，招聘维护成本低

### 6.4 扩展性
- ✅ **模块化设计**，易于添加新功能
- ✅ **Zustand中间件**，可接入DevTools、持久化
- ✅ **Canvas分层**，未来可升级Pixi.js
- ✅ **RESTful API**，未来可切换WebSocket

---

## 7. 技术栈风险与应对

### 7.1 Canvas渲染复杂度
**风险**：手写Canvas代码量大，维护困难

**应对**：
- 封装Canvas工具类（TileRenderer、BoardRenderer）
- 明确职责分离（渲染逻辑 vs 游戏逻辑）
- 未来可重构为Pixi.js（API相似）

---

### 7.2 轮询性能开销
**风险**：每500ms请求一次API，可能造成后端压力

**应对**：
- 仅游戏进行中轮询，其他时候停止
- 使用 `refetchInterval` 动态调整频率
- 后端缓存游戏状态，减少数据库查询
- 未来可升级为WebSocket推送

---

### 7.3 TypeScript学习曲线
**风险**：团队不熟悉TypeScript，影响开发速度

**应对**：
- 提供类型定义模板（Tile、GameState等）
- 关键逻辑添加注释
- 允许初期使用 `any`（后续重构）

---

## 8. 开发环境要求

### 8.1 软件版本
- Node.js >= 18.x
- npm >= 9.x 或 pnpm >= 8.x
- TypeScript >= 5.x

### 8.2 IDE推荐
- **VSCode**（推荐）
  - 插件：ESLint、Prettier、Tailwind CSS IntelliSense
- WebStorm（可选）

### 8.3 浏览器
- Chrome >= 100
- Firefox >= 100
- Edge >= 100
- Safari >= 15

---

## 9. 对比备选方案

### 9.1 为什么不用Vue 3？
- Vue 3的Composition API确实简洁，响应式系统强大
- 但React生态更成熟，游戏开发案例更多
- 团队熟悉度通常React更高

**结论**：如果团队更熟悉Vue，完全可以替换为 `Vue 3 + Pinia + Vite`

---

### 9.2 为什么不用Pixi.js？
- Pixi.js是专业2D游戏引擎，精灵动画、粒子系统强大
- 但包体积大（400KB+），对于简单麻将游戏过重
- MVP阶段原生Canvas足够

**结论**：未来需要复杂动画时，可重构为Pixi.js

---

### 9.3 为什么不用WebSocket？
- WebSocket实时推送，适合多人对战
- 但单机版不需要实时性，RESTful轮询简单够用
- WebSocket增加开发复杂度（连接管理、断线重连）

**结论**：未来多人对战时，再升级为WebSocket

---

## 10. 总结

本项目采用 **React + TypeScript + Vite + Zustand + Canvas** 技术栈，具备以下特点：

✅ **现代化**：2024-2025主流技术，生态成熟
✅ **高性能**：Vite构建快、Canvas渲染快、轻量状态管理
✅ **类型安全**：TypeScript全覆盖，减少运行时错误
✅ **易维护**：前后端分离、组件化、模块化
✅ **可扩展**：架构灵活，未来可升级为多人对战、3D效果

该技术栈在**开发效率、性能、可维护性、扩展性**之间达到最佳平衡，适合本项目的MVP快速迭代需求。

---

**文档结束**
