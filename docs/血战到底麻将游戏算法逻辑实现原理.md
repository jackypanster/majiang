# 血战到底麻将游戏算法逻辑实现原理

本文档描述了基于“血战到底麻将规则（埋三张定缺微调版）”的游戏算法逻辑实现原理。设计原则是使用事件驱动的状态机管理游戏流程，确保每个环节的输入、处理和输出都明确定义。所有判断基于规则的精确条件，避免模糊性。数据结构使用固定枚举和计数数组以提升效率。游戏假设4人局，支持单机（AI玩家）或多人模式。算法复杂度控制在每回合O(牌数 × 花色) = O(14 × 3) = O(42)，通过预排序和增量更新实现。

为确保清晰，本文档在每个环节后添加“逻辑验证点”和“潜在边缘case处理”，展开讨论可能的不确定性（如牌墙计算、埋牌影响）。埋牌仅用于定缺验证，不参与牌型或计分；它从起手牌中移除，导致起手牌减少。最终胡牌时的总牌面由“一对将+三个面子”的结构决定，不再是固定的14张。

## 1. 数据结构设计

### 核心数据对象
- **牌（Tile）**：结构体，包含`suit`（花色：枚举0=筒、1=条、2=万）和`rank`（点数：1-9）。所有牌唯一标识（可选添加ID用于调试）。总牌库初始化为List<Tile>（108张：每suit-rank组合4张）。
- **牌墙（Wall）**：Deque<Tile>（双端队列），支持从尾端pop（模拟摸牌）。初始容量108，洗牌后填充。
- **玩家（Player）**：类或结构体，4个实例（索引0-3，0为初始庄家）。属性：
  - `hand`：SortedList<Tile>（手牌，按suit升序、rank升序排序，便于计数）。初始13/14张，埋牌后10/11张。
  - `buried`：List<Tile>（埋牌，3张，面下，仅验证用）。花色必须相同（初始化时验证）。
  - `missing_suit`：int（-1=未定，0-2=缺门）。基于buried[0].suit设置。
  - `melds`：List<Meld>（明牌：碰/杠）。Meld结构体：`type`（Pong=3张、Kong=4张）、`tiles`（List<Tile>）。
  - `state`：枚举（Normal=正常、Listening=听牌、Hu=已胡、Out=流局出局）。
  - `fan`：int（总番数，实时计算）。
  - `score`：int（当前积分，包含杠分）。
  - `last_hu_fan`：int（漏胡阈值，上次过胡番数，默认-1）。
- **游戏状态（GameState）**：
  - `dealer`：int（庄家索引，0-3）。
  - `current_player`：int（当前回合玩家）。
  - `hu_count`：int（已胡玩家数，0-3；达3结束局）。
  - `events`：PriorityQueue<Event>（事件队列，高优先级先处理：Hu > Kong > Pong > Pass）。Event结构体：`type`（Draw/Discard/Pong/Kong/Hu）、`player`（发起者）、`tile`（相关牌）、`priority`（int）。
  - `kong_payments`：Map<Player, int>（杠分记录：键=支付者，值=金额）。
  - `public_discard`：List<Tile>（公共打出牌堆，按回合顺序）。
  - `wall_size`：int（牌墙剩余张数，初始55）。
  - `is_huangzhuang`：bool（流局标志）。

### 辅助结构
- **PatternChecker**：模块函数，输入：hand + melds + extra_tile（可选胡牌）。输出：bool（可胡）、List<Pattern>（匹配牌型，如Pinfu/Pengpeng）。使用计数数组`count[3][10]`（suit-rank张数）实现。
- **FanCalculator**：模块函数，输入：Pattern列表 + 特殊标志（自摸/门清等）。输出：int（总番）。使用规则表（JSON-like Map<Pattern, int>）和互斥检查（if Pinfu && Pengpeng then skip Pengpeng）。

**逻辑验证点**：所有List使用排序/哈希确保O(1)查找相同牌。buried不计入hand或melds，仅在流局验证。边缘case：如果buried非同suit（客户端错误），初始化抛异常或默认罚分。

## 2. 游戏初始化算法

### 2.1 洗牌与配牌
1. **生成牌库**：for suit in 0..2: for rank in 1..9: add 4 × Tile(suit, rank) to deck。结果：List<Tile> deck (size=108)。
2. **洗牌**：Fisher-Yates：for i from 107 downto 1: swap deck[i] with deck[random(0..i)]。使用固定种子可选（测试用）。
3. **填充牌墙**：Wall = Deque(deck[0..107])；实际配牌从Wall pop 53张（庄家14 + 闲家13×3），剩余Wall size=55。
4. **配牌分配**：
   - 玩家0 (庄家)：pop 14张 to hand[0]，sort。
   - 玩家1-3：各pop 13张 to hand[i]，sort。
   - 验证：总pop=53，确保无重复（count[suit][rank] ≤4全局）。

### 2.2 定缺埋牌
1. **玩家输入**：每个玩家选择3张从hand中（客户端UI：列出手牌，按suit分组）。服务器验证：selected[3].suit all equal，且in hand。
2. **执行埋牌**：for each player: remove selected from hand (O(log n) via SortedList)，add to buried。更新missing_suit = buried[0].suit。
   - 结果：hand[0] size=11，hand[1-3] size=10。
3. **牌墙不变**：埋牌移除不回Wall（总可用牌仍55张摸牌）。
4. **庄家首出**：玩家0从hand pop 1张（玩家选择），add to public_discard。触发响应阶段（无摸牌）。

**逻辑验证点**：起手牌减少（10/11张）是本规则的核心。玩家在后续摸牌过程中，目标是组成一个11张（一对将+三组面子）或14张（七对）的有效胡牌牌型。埋掉的3张牌不参与游戏，仅用于流局验证。边缘case：玩家无3张同suit可选？规则要求必须选，客户端强制或随机罚。

**展开讨论**：埋牌减少起手牌可能使早期听牌难，但规则意在强调定缺承诺。算法不调整牌型结构，仍用标准14张检查（hand + melds + extra =14），因为埋牌“不存在”于游戏中。

## 3. 游戏主循环算法

### 3.1 回合流程（状态机驱动）

状态机：enum State { Init, Draw, AfterDraw, Discard, Respond, AfterPong, AfterKong, HuProcess, EndRound }。



1.  **Init 阶段**: 初始化游戏，洗牌、发牌、埋牌。完成后进入庄家的 `Draw` 阶段。



2.  **Draw 阶段 (摸牌)**:

    -   `current_player` 从牌墙摸一张牌。

    -   若牌墙为空，进入 `EndRound` (流局)。

    -   摸牌后，进入 `AfterDraw` 阶段。



3.  **AfterDraw 阶段 (摸牌后决策)**:

    -   当前玩家可以选择：

        -   **打牌**: 进入 `Discard` 阶段。

        -   **自摸**: 进入 `HuProcess` 阶段。

        -   **暗杠/补杠**: 进入 `AfterKong` 阶段。



4.  **Discard 阶段 (打牌)**:

    -   当前玩家选择一张手牌打出。

    -   进入 `Respond` 阶段，等待其他玩家响应。



5.  **Respond 阶段 (响应决策)**:

    -   其他玩家根据被打出的牌，在限时窗口内选择操作（胡、杠、碰、过）。

    -   服务器根据优先级（胡 > 杠 > 碰）进行仲裁。

    -   **结果**:

        -   **有人胡**: 进入 `HuProcess` 阶段。

        -   **有人杠**: `current_player` 变为杠牌者，进入 `AfterKong` 阶段。

        -   **有人碰**: `current_player` 变为碰牌者，进入 `AfterPong` 阶段。

        -   **无人响应**: `current_player` 轮转至下家，进入 `Draw` 阶段。



6.  **AfterPong 阶段 (碰后)**:

    -   碰牌玩家必须打出一张牌。

    -   进入 `Discard` 阶段。



7.  **AfterKong 阶段 (杠后)**:

    -   杠牌玩家从牌墙末尾补一张牌。

    -   检查是否“杠上花”（自摸）。若是，进入 `HuProcess`。

    -   否则，进入 `Discard` 阶段，杠牌玩家必须打出一张牌。



8.  **HuProcess 阶段 (胡牌处理)**:

    -   结算胡牌分数。

    -   被胡的玩家状态变为 `Hu`。

    -   若胡牌玩家数 < 3，游戏继续，轮到下一位玩家进入 `Draw` 阶段。

    -   否则，进入 `EndRound`。



9.  **EndRound 阶段**: 游戏结束，进行最终结算。

**逻辑验证点**：事件优先级确保Hu不被抢（e.g., 打出后先全Hu检查，再Kong）。漏胡：last_hu_fan只同圈内有效（圈=一打牌后响应），动牌(Draw/Discard) reset to -1。边缘case：多重响应冲突？队列FIFO + 优先级解决（Hu独占）。

**展开讨论**：血战模式下，已胡玩家不参与但可“观察”事件（如杠上炮针对其）。如果牌墙早空（罕见），直接流局；算法用wall_size实时监控。

### 3.2 特殊事件处理
- **天胡**：庄家执行埋牌操作后，检查其剩余的11张手牌。`PatternChecker(hand[dealer], melds, null)` 若为真，则构成天胡。
- **地胡**：闲家执行埋牌操作后，在其第一个摸牌轮次，摸入一张牌后。检查其手牌（10张+1张摸入）是否构成胡牌牌型。
- **杠上花**：Kong后Draw：if supplemental and self_hu: fan+=1。
- **杠上炮**：Kong后Discard：响应Hu时 if last_event==Kong: fan+=1。
- **海底捞月**：Draw时 if wall_size==0 (摸牌前判断，即摸的是最后一张牌): hu时 fan+=1。


**逻辑验证点**：特殊胡叠加到总fan，不改变基本牌型。边缘case：天胡+清一色？计算器先基本再+5。

## 4. 胡牌判断算法

### 4.1 牌型检查原理
输入：hand + melds + extra_tile。输出：can_hu (bool), patterns (List<string>)。

1. **预处理**：
   - `total_tiles` = hand + flatten(melds) + extra。
   - `suits_used` = unique suits in `total_tiles`；if >2: return false (不缺门)。
   - `count[3][10]` = 0；for each tile: `count[suit][rank]++`。

2. **结构化牌型匹配**：
   - **核心思想**：胡牌结构为“一对将 + 三个面子”。算法通过尝试移除一对将，然后检查剩余的牌是否能分解为三个面子（顺子、刻子或杠）来验证。
   - **步骤**：
     a. 遍历`total_tiles`中所有牌，尝试每一种可能成为“将”的组合（`count[s][r] >= 2`）。
     b. 对于每一个候选的“将”，从`count`中移除这两张牌，得到一个临时的`temp_count`。
     c. 调用递归函数`check_sets(temp_count)`，判断剩余的牌是否能分解为三组面子。
   - **递归函数 `check_sets(counts)`**：
     - **Base Case**: 如果牌数为0，说明分解成功，返回`true`。
     - **Recursive Step**:
       - 优先尝试移除一个“杠”（`count[s][r] == 4`），然后递归调用`check_sets`。
       - 再尝试移除一个“刻子”（`count[s][r] >= 3`），然后递归调用`check_sets`。
       - 最后尝试移除一个“顺子”（`count[s][r]`, `[r+1]`, `[r+2]`均`>= 1`），然后递归调用`check_sets`。
     - 如果以上尝试都失败，返回`false`。

3. **番型计算**：
   - 根据成功分解出的面子组合（例如全是刻子/杠，则为“对对胡”），确定基础牌型。
   - 叠加计算门清、自摸、带根等附加番。
   - `total_fan` = `base_fan` + `addon_fan`。

**逻辑验证点**：此算法不再依赖固定的总牌数，而是验证牌型结构。一个杠被视为一个4张的“面子”。这统一了所有胡牌情况，无论是11张、12张还是更多。备忘录（Memoization）可用于优化递归性能。

## 5. 计分与结算算法

### 5.1 即时结算
- **Kong**：Ming: payer (discard_player) score -=2*base；kong_player +=2*base。
  - An/Bu: each other score -=1*base；kong_player +=3*base。
  - Add to kong_payments。
- **Hu**：base_score = base * (1 << total_fan) (2^fan)。
  - Self: others each -= base_score；hu_player +=3*base_score (庄double: if dealer +base_score)。
  - Point: discard_player -= base_score；hu_player +=base_score。
  - Rob: kong_player as point。

### 5.2 局末结算
- Update dealer: 在一炮多响的情况下，由第一个胡牌的玩家坐庄。其他情况（闲家胡牌、庄家胡牌、流局）按标准规则延续。
- Total score accumulate。

**逻辑验证点**：base=1默认。公式精确：self = fan_base *3 - kongs owed。边缘case：多胡分摊？一人点炮多付。

## 6. 流局处理算法

1. **Trigger**：wall_size==0 post-Draw fail。
2. **Huang Process**：
   - For each player if not Hu:
     - Flower pig: if suits_in(hand+melds)==3: score -=48*base。
     - Buried check: if buried suits not uniform: score -=48*base (视为花猪)。
3. **Da Jiao**：for non-listening non-pig: pay to each listening max_possible_fan*base (precompute per player: max pattern fan from listening extras)。
   - Refund kongs: for non-listening: kong_payments refund to them。
4. Dealer unchanged。

**逻辑验证点**：Listening: pre-flow PatternChecker with extras。No self-check (no pay to self)。边缘case：All hu pre-flow? Skip huang。

**展开讨论**：Da Jiao“最大可能番”= enumerate 34 extras, max fan；O(34*check)=可接受。埋罚独立，确保验证强制。

## 7. 整体架构与扩展性

- **FSM**：switch(state) drive loop；events decouple (e.g., UI subscribe)。
- **AI**：MCTS: simulate 1000 paths from current, max EV score。
- **Test**：Fixed seed replay；assert hu_count==3 or huang。
- **扩展**：Param base_fan；埋数=3 fixed。