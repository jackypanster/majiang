# 血战到底麻将游戏算法逻辑实现原理

本文档描述了基于“血战到底麻将规则（埋三张定缺简化版）”的游戏算法逻辑实现原理。设计原则是使用事件驱动的状态机管理游戏流程，确保每个环节的输入、处理和输出都明确定义。所有判断基于规则的精确条件，避免模糊性。数据结构使用固定枚举和计数数组以提升效率。游戏假设 4 人局，默认 1 名真人 + 3 名 AI，AI 即时响应，真人玩家可以自由思考。算法复杂度控制在每回合 O(牌数 × 花色) = O(14 × 3) = O(42)，通过预排序和增量更新实现。

为确保清晰，本文档在每个环节后添加“逻辑验证点”和“潜在边缘 case 处理”，展开讨论可能的不确定性（如牌墙计算、埋牌影响）。埋牌仅用于定缺验证，不参与牌型或计分；它从起手牌中移除，导致起手牌减少。胡牌结构固定为“一对将 + 三个面子”，暗牌张数在任意时刻都不会超过 14 张。玩家第一次胡牌后暗牌结构锁定，但仍需按顺序摸牌并立即打出新摸的牌，逻辑层需支持再次胡牌。得分采用“番数即分数”的简化模型，不再使用指数倍数。

## 1. 数据结构设计

### 核心数据对象
- **牌（Tile）**：结构体，包含`suit`（花色：枚举0=筒、1=条、2=万）和`rank`（点数：1-9）。所有牌唯一标识（可选添加ID用于调试）。总牌库初始化为List<Tile>（108张：每suit-rank组合4张）。
- **牌墙（Wall）**：Deque<Tile>（双端队列），支持从尾端pop（模拟摸牌）。初始容量108，洗牌后填充。
- **玩家（Player）**：类或结构体，4个实例（索引0-3，0为初始庄家）。属性：
  - `hand`：SortedList<Tile>（手牌，按suit升序、rank升序排序，便于计数）。初始13/14张，埋牌后10/11张。
  - `buried`：List<Tile>（埋牌，3张，面下，仅验证用）。花色必须相同（初始化时验证）。
  - `missing_suit`：int（-1=未定，0-2=缺门）。基于buried[0].suit设置。
  - `melds`：List<Meld>（明牌：碰/杠）。Meld结构体：`type`（Pong=3张、Kong=4张）、`tiles`（List<Tile>）。
  - `state`：枚举（Normal=正常、Listening=听牌、Hu=已胡）。
  - `fan`：int（总番数，实时计算）。
  - `score`：int（当前积分，包含杠分）。
  - `last_hu_fan`：int（漏胡阈值，上次过胡番数，默认-1）。
- **游戏状态（GameState）**：
  - `dealer`：int（庄家索引，0-3）。
  - `current_player`：int（当前回合玩家）。
  - `hu_count`：int（已胡次数，用于统计得分；游戏持续到牌墙耗尽，不再以 3 家胡为结束条件）。
  - `events`：PriorityQueue<Event>（事件队列，高优先级先处理：Hu > Kong > Pong > Pass）。Event结构体：`type`（Draw/Discard/Pong/Kong/Hu）、`player`（发起者）、`tile`（相关牌）、`priority`（int）。
  - `kong_payments`：Map<Player, int>（杠分记录：键=支付者，值=金额）。
  - `public_discard`：List<Tile>（公共打出牌堆，按回合顺序）。
  - `wall_size`：int（牌墙剩余张数，初始55）。

### 辅助结构
- **PatternChecker**：模块函数，输入：hand + melds + extra_tile（可选胡牌）。输出：bool（可胡）、List<Pattern>（匹配牌型，如Pinfu/Pengpeng）。使用计数数组`count[3][10]`（suit-rank张数）实现。
- **FanCalculator**：模块函数，输入：Pattern列表 + 特殊标志（自摸/门清等）。输出：int（总番）。使用规则表（JSON-like Map<Pattern, int>）和互斥检查（if Pinfu && Pengpeng then skip Pengpeng）。

**逻辑验证点**：所有List使用排序/哈希确保O(1)查找相同牌。buried不计入hand或melds，仅用于缺门验证。边缘case：如果buried非同suit（客户端错误），初始化抛异常或默认罚分。

## 2. 游戏初始化算法

### 2.1 洗牌与配牌
1. **生成牌库**：for suit in 0..2: for rank in 1..9: add 4 × Tile(suit, rank) to deck。结果：List<Tile> deck (size=108)。
2. **洗牌**：Fisher-Yates：for i from 107 downto 1: swap deck[i] with deck[random(0..i)]。使用固定种子可选（测试用）。
3. **填充牌墙**：Wall = Deque(deck[0..107])；实际配牌从Wall pop 53张（庄家14 + 闲家13×3），剩余Wall size=55。
4. **配牌分配**：
   - 玩家0 (庄家)：pop 14张 to hand[0]，sort。
   - 玩家1-3：各pop 13张 to hand[i]，sort。
   - 验证：总pop=53，确保无重复（count[suit][rank] ≤4全局）。

### 2.2 定缺埋牌
1. **玩家输入**：每个玩家选择3张从hand中（客户端UI：列出手牌，按suit分组）。服务器验证：selected[3].suit all equal，且in hand。
2. **执行埋牌**：for each player: remove selected from hand (O(log n) via SortedList)，add to buried。更新missing_suit = buried[0].suit。
   - 结果：hand[0] size=11，hand[1-3] size=10。
3. **牌墙不变**：埋牌移除不回Wall（总可用牌仍55张摸牌）。
4. **庄家首出**：玩家0从hand pop 1张（玩家选择），add to public_discard。触发响应阶段（无摸牌）。

**逻辑验证点**：起手牌减少（10/11张）是本规则的核心。玩家在后续摸牌过程中，始终以“缺门成立的一对将 + 三个面子”为胡牌目标，不支持七对等特殊牌型。埋掉的 3 张牌不参与游戏，仅用于缺门校验。边缘 case：若玩家在客户端无 3 张同花色可选，需由前端强制选择或触发罚则。

**展开讨论**：埋牌减少起手牌可能使早期听牌难，但规则意在强调定缺承诺。算法不调整牌型结构，仍用标准14张检查（hand + melds + extra =14），因为埋牌“不存在”于游戏中。

## 3. 游戏主循环算法

### 3.1 回合流程（状态机驱动）

状态机：enum State { Init, Draw, AfterDraw, Discard, Respond, AfterPong, AfterKong, HuProcess, EndRound }。



1.  **Init 阶段**: 初始化游戏，洗牌、发牌、埋牌。完成后进入庄家的 `Draw` 阶段。



2.  **Draw 阶段 (摸牌)**:

    -   `current_player` 从牌墙摸一张牌。

    -   若牌墙为空，游戏结束，进入 `EndRound` 阶段进行最终结算。

    -   摸牌后，进入 `AfterDraw` 阶段。



3.  **AfterDraw 阶段 (摸牌后决策)**:

    -   当前玩家可以选择：

        -   **打牌**: 进入 `Discard` 阶段。

        -   **自摸**: 进入 `HuProcess` 阶段。

        -   **暗杠/补杠**: 进入 `AfterKong` 阶段。



4.  **Discard 阶段 (打牌)**:

    -   当前玩家选择一张手牌打出。

    -   进入 `Respond` 阶段，等待其他玩家响应。



5.  **Respond 阶段 (响应决策)**:

    -   其他玩家根据被打出的牌，在限时窗口内选择操作（胡、杠、碰、过）。

    -   服务器根据优先级（胡 > 杠 > 碰）进行仲裁。

    -   **结果**:

        -   **有人胡**: 进入 `HuProcess` 阶段。

        -   **有人杠**: `current_player` 变为杠牌者，进入 `AfterKong` 阶段。

        -   **有人碰**: `current_player` 变为碰牌者，进入 `AfterPong` 阶段。

        -   **无人响应**: `current_player` 轮转至下家，进入 `Draw` 阶段。



6.  **AfterPong 阶段 (碰后)**:

    -   碰牌玩家必须打出一张牌。

    -   进入 `Discard` 阶段。



7.  **AfterKong 阶段 (杠后)**:

    -   杠牌玩家从牌墙末尾补一张牌。

    -   检查是否“杠上花”（自摸）。若是，进入 `HuProcess`。

    -   否则，进入 `Discard` 阶段，杠牌玩家必须打出一张牌。



8.  **HuProcess 阶段 (胡牌处理)**:

    -   计算胡牌番数，结算点炮或自摸所得，并同时结算已产生的杠分。

    -   将胡牌玩家标记为 `is_hu=True`，锁定其暗牌结构：后续摸牌时仅暂存摸入牌并立即打出，不允许选择手牌中其他牌打出。

    -   记录胡牌事件（含番数、来源、被点炮者等信息），供终局汇总。

    -   若牌墙仍有剩余，则轮转至下一位玩家进入 `Draw` 阶段（胡牌者仍在顺序中，会按锁定规则摸打一张牌）；若牌墙耗尽则进入 `EndRound`。



9.  **EndRound 阶段**: 游戏结束，进行最终结算。

**逻辑验证点**：事件优先级确保 Hu 不被抢（例如打出牌后先统一检查 Hu，再处理杠）。`last_hu_fan`（若启用漏胡规则）只在同圈内生效，并在玩家摸完并打出所摸之牌后重置。多重响应冲突使用 FIFO + 优先级队列解决（Hu 拥有最高优先级），同时需确保锁定状态下的玩家只能打出刚摸入的牌。

**展开讨论**：血战模式下，已胡玩家仍需留在循环中以执行“摸一张 → 若可胡则宣胡，否则打出该张”的流程。若牌墙提前耗尽，立即进入 `EndRound`；`wall_size` 持续监控剩余牌量，保障终局触发准确。

### 3.2 特殊事件处理
- **天胡**：庄家执行埋牌操作后，检查其剩余的11张手牌。`PatternChecker(hand[dealer], melds, null)` 若为真，则构成天胡。
- **地胡**：闲家执行埋牌操作后，在其第一个摸牌轮次，摸入一张牌后。检查其手牌（10张+1张摸入）是否构成胡牌牌型。
- **杠上花**：Kong后Draw：if supplemental and self_hu: fan+=1。
- **杠上炮**：Kong后Discard：响应Hu时 if last_event==Kong: fan+=1。
- **海底捞月**：Draw时 if wall_size==0 (摸牌前判断，即摸的是最后一张牌): hu时 fan+=1。


**逻辑验证点**：特殊胡叠加到总fan，不改变基本牌型。边缘case：天胡+清一色？计算器先基本再+5。

## 4. 胡牌判断算法

### 4.1 牌型检查原理
输入：hand + melds + extra_tile。输出：can_hu (bool), patterns (List<string>)。

1. **预处理**：
   - `total_tiles` = hand + flatten(melds) + extra。
   - `suits_used` = unique suits in `total_tiles`；if >2: return false (不缺门)。
   - `count[3][10]` = 0；for each tile: `count[suit][rank]++`。

2. **结构化牌型匹配**：
   - **核心思想**：胡牌结构为“一对将 + 三个面子”。算法通过尝试移除一对将，然后检查剩余的牌是否能分解为三个面子（顺子、刻子或杠）来验证。
   - **步骤**：
     a. 遍历`total_tiles`中所有牌，尝试每一种可能成为“将”的组合（`count[s][r] >= 2`）。
     b. 对于每一个候选的“将”，从`count`中移除这两张牌，得到一个临时的`temp_count`。
     c. 调用递归函数`check_sets(temp_count)`，判断剩余的牌是否能分解为三组面子。
   - **递归函数 `check_sets(counts)`**：
     - **Base Case**: 如果牌数为0，说明分解成功，返回`true`。
     - **Recursive Step**:
       - 优先尝试移除一个“杠”（`count[s][r] == 4`），然后递归调用`check_sets`。
       - 再尝试移除一个“刻子”（`count[s][r] >= 3`），然后递归调用`check_sets`。
       - 最后尝试移除一个“顺子”（`count[s][r]`, `[r+1]`, `[r+2]`均`>= 1`），然后递归调用`check_sets`。
     - 如果以上尝试都失败，返回`false`。

3. **番型计算**：
   - 根据成功分解出的面子组合（例如全是刻子/杠，则为“对对胡”），确定基础牌型。
   - 叠加计算门清、自摸、带根等附加番。
   - `total_fan` = `base_fan` + `addon_fan`。

**逻辑验证点**：此算法不再依赖固定的总牌数，而是验证牌型结构。一个杠被视为一个4张的“面子”。这统一了所有胡牌情况，无论是11张、12张还是更多。备忘录（Memoization）可用于优化递归性能。

## 5. 计分与结算算法

### 5.1 即时结算
- **Kong**：Ming: payer (discard_player) score -=2*base；kong_player +=2*base。
  - An/Bu: each other score -=1*base；kong_player +=3*base。
  - Add to kong_payments。
- **Hu**：`total_fan = Scorer.calculate_score(...)`，番数即为记分单位。
  - **自摸**：其余三家各扣 `total_fan` 分，胡牌玩家加 `3 * total_fan` 分（庄家不再额外加倍）。
  - **点炮**：点炮者扣 `total_fan` 分，胡牌玩家加相同分数。
  - **杠上炮**：视为点炮，支付方为被杠者。

### 5.2 局末结算
- Update dealer: 在一炮多响的情况下，由第一个胡牌的玩家坐庄。其他情况（闲家胡牌、庄家胡牌、流局）按标准规则延续。
- Total score accumulate。

**逻辑验证点**：base=1默认。公式精确：self = fan_base *3 - kongs owed。边缘case：多胡分摊？一人点炮多付。

## 6. 游戏结束处理算法

1. **触发条件**：`wall_size == 0`（牌墙摸完）。
2. **结算步骤**：
   - 统计所有玩家的得分（包括胡牌得分和杠分）。
   - 杠分在发生时已即时结算（刮风下雨），无需额外处理。
   - 不执行查花猪、查大叫等额外流程。
3. **最终分数**：所有玩家的当前 `score` 即为最终积分。

**逻辑验证点**：游戏仅在牌墙摸完时结束，无论是否有玩家胡牌。已胡玩家的得分和杠分已在游戏过程中实时结算完成。

## 7. 整体架构与扩展性

- **FSM**：switch(state) drive loop；events decouple (e.g., UI subscribe)。
- **AI**：使用固定优先级策略（Hu > Kong > Pong > Pass），后续可替换为更复杂的评估函数。
- **Test**：固定随机种子回放，断言 `EndRound` 仅在牌墙耗尽或显式终止时触发，并验证已胡牌玩家不会再次摸牌或出牌。
- **扩展**：可参数化番数权重、定缺张数等配置；当前埋数固定为 3。
