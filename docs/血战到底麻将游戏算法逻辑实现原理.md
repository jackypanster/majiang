# 血战到底麻将游戏算法逻辑实现原理

本文档描述了基于"血战到底麻将规则（埋三张定缺简化版）"的游戏算法逻辑实现原理。设计原则是使用事件驱动的状态机管理游戏流程，确保每个环节的输入、处理和输出都明确定义。所有判断基于规则的精确条件，避免模糊性。数据结构使用固定枚举和计数数组以提升效率。游戏假设 4 人局，默认 1 名真人 + 3 名 AI，AI 即时响应，真人玩家可以自由思考。算法复杂度控制在每回合 O(牌数 × 花色) = O(14 × 3) = O(42)，通过预排序和增量更新实现。

为确保清晰，本文档在每个环节后添加"逻辑验证点"和"潜在边缘 case 处理"，展开讨论可能的不确定性（如牌墙计算、埋牌影响）。埋牌仅用于定缺验证，不参与牌型或计分；它从起手牌中移除，导致起手牌减少。胡牌结构固定为"一对将 + 三个面子"。玩家第一次胡牌后暗牌结构锁定，但仍需按顺序摸牌并立即打出新摸的牌，逻辑层需支持再次胡牌。得分采用"番数即分数"的简化模型，不再使用指数倍数。

## 0. 手牌数量规则（核心约束）

**所有玩家在正常游戏循环中的手牌数量都相同：**

1. **发牌阶段**：
   - 庄家：14张
   - 闲家：13张

2. **埋牌后**：
   - 庄家：14 - 3 = **11张**
   - 闲家：13 - 3 = **10张**

3. **庄家第一次出牌后**：
   - 庄家：11 - 1 = **10张**
   - 闲家：**10张**

4. **之后所有玩家的正常循环**（包括庄家和闲家）：
   - **摸牌前**：10张
   - **摸牌后**：11张
   - **打牌后**：10张

**关键约束**：
- ✅ 庄家的特殊性仅在于：发牌时多1张，第一个出牌，之后和闲家完全一样
- ✅ 所有玩家在游戏循环中都是"10张 → 摸牌 → 11张 → 打牌 → 10张"
- ✅ 杠牌后：暗牌减3张（移出4张，补摸1张），但必须打牌，最终回到10张
- ❌ **绝对不会出现超过11张手牌的情况**（如果出现12张及以上，说明有bug）

**这是实现中最容易出错的地方，必须严格遵守！**

## 1. 数据结构设计

### 核心数据对象
- **牌（Tile）**：结构体，包含`suit`（花色：枚举0=筒、1=条、2=万）和`rank`（点数：1-9）。所有牌唯一标识（可选添加ID用于调试）。总牌库初始化为List<Tile>（108张：每suit-rank组合4张）。
- **牌墙（Wall）**：Deque<Tile>（双端队列），支持从尾端pop（模拟摸牌）。初始容量108，洗牌后填充。
- **玩家（Player）**：类或结构体，4个实例（索引0-3，0为初始庄家）。属性：
  - `hand`：SortedList<Tile>（手牌，按suit升序、rank升序排序，便于计数）。初始13/14张，埋牌后10/11张。
  - `buried`：List<Tile>（埋牌，3张，面下，仅验证用）。花色必须相同（初始化时验证）。
  - `missing_suit`：int（-1=未定，0-2=缺门）。基于buried[0].suit设置。
  - `melds`：List<Meld>（明牌：碰/杠）。Meld结构体：`type`（Pong=3张、Kong=4张）、`tiles`（List<Tile>）。
  - `state`：枚举（Normal=正常、Listening=听牌、Hu=已胡）。
  - `fan`：int（总番数，实时计算）。
  - `score`：int（当前积分，包含杠分）。
  - `last_hu_fan`：int（漏胡阈值，上次过胡番数，默认-1）。
- **游戏状态（GameState）**：
  - `dealer`：int（庄家索引，0-3）。
  - `current_player`：int（当前回合玩家）。
  - `hu_count`：int（已胡次数，用于统计得分；游戏持续到牌墙耗尽，不再以 3 家胡为结束条件）。
  - `events`：PriorityQueue<Event>（事件队列，高优先级先处理：Hu > Kong > Pong > Pass）。Event结构体：`type`（Draw/Discard/Pong/Kong/Hu）、`player`（发起者）、`tile`（相关牌）、`priority`（int）。
  - `kong_payments`：Map<Player, int>（杠分记录：键=支付者，值=金额）。
  - `public_discard`：List<Tile>（公共打出牌堆，按回合顺序）。
  - `wall_size`：int（牌墙剩余张数，初始55）。

### 辅助结构
- **PatternChecker**：模块函数，输入：hand + melds + extra_tile（可选胡牌）。输出：bool（可胡）、List<Pattern>（匹配牌型，如Pinfu/Pengpeng）。使用计数数组`count[3][10]`（suit-rank张数）实现。
- **FanCalculator**：模块函数，输入：Pattern列表 + 特殊标志（自摸/门清等）。输出：int（总番）。使用规则表（JSON-like Map<Pattern, int>）和互斥检查（if Pinfu && Pengpeng then skip Pengpeng）。

**逻辑验证点**：所有List使用排序/哈希确保O(1)查找相同牌。buried不计入hand或melds，仅用于缺门验证。边缘case：如果buried非同suit（客户端错误），初始化抛异常或默认罚分。

## 2. 游戏初始化算法

### 2.1 洗牌与配牌
1. **生成牌库**：for suit in 0..2: for rank in 1..9: add 4 × Tile(suit, rank) to deck。结果：List<Tile> deck (size=108)。
2. **洗牌**：Fisher-Yates：for i from 107 downto 1: swap deck[i] with deck[random(0..i)]。使用固定种子可选（测试用）。
3. **填充牌墙**：Wall = Deque(deck[0..107])；实际配牌从Wall pop 53张（庄家14 + 闲家13×3），剩余Wall size=55。
4. **配牌分配**：
   - 玩家0 (庄家)：pop 14张 to hand[0]，sort。
   - 玩家1-3：各pop 13张 to hand[i]，sort。
   - 验证：总pop=53，确保无重复（count[suit][rank] ≤4全局）。

### 2.2 定缺埋牌
1. **玩家输入**：每个玩家选择3张从hand中（客户端UI：列出手牌，按suit分组）。服务器验证：selected[3].suit all equal，且in hand。
2. **执行埋牌**：for each player: remove selected from hand (O(log n) via SortedList)，add to buried。更新missing_suit = buried[0].suit。
   - 结果：hand[0] size=11，hand[1-3] size=10。
3. **牌墙不变**：埋牌移除不回Wall（总可用牌仍55张摸牌）。
4. **庄家首出**：玩家0从hand pop 1张（玩家选择），add to public_discard。触发响应阶段（无摸牌）。

**逻辑验证点**：起手牌减少（10/11张）是本规则的核心。玩家在后续摸牌过程中，始终以“缺门成立的一对将 + 三个面子”为胡牌目标，不支持七对等特殊牌型。埋掉的 3 张牌不参与游戏，仅用于缺门校验。边缘 case：若玩家在客户端无 3 张同花色可选，需由前端强制选择或触发罚则。

**展开讨论**：埋牌减少起手牌可能使早期听牌难，但规则意在强调定缺承诺。算法不调整牌型结构，仍用标准14张检查（hand + melds + extra =14），因为埋牌“不存在”于游戏中。

## 3. 游戏主循环算法

### 3.1 回合流程（状态机驱动）

状态机：enum State { Init, Draw, AfterDraw, Discard, Respond, AfterPong, AfterKong, HuProcess, EndRound }。



1.  **Init 阶段**: 初始化游戏，洗牌、发牌、埋牌。完成后进入庄家的 `Draw` 阶段。



2.  **Draw 阶段 (摸牌)**:

    -   `current_player` 从牌墙摸一张牌。

    -   若牌墙为空，游戏结束，进入 `EndRound` 阶段进行最终结算。

    -   摸牌后，进入 `AfterDraw` 阶段。



3.  **AfterDraw 阶段 (摸牌后决策)**:

    -   当前玩家可以选择：

        -   **打牌**: 进入 `Discard` 阶段。

        -   **自摸**: 进入 `HuProcess` 阶段。

        -   **暗杠/补杠**: 进入 `AfterKong` 阶段。



4.  **Discard 阶段 (打牌)**:

    -   当前玩家选择一张手牌打出。

    -   进入 `Respond` 阶段，等待其他玩家响应。



5.  **Respond 阶段 (响应决策)**:

    -   其他玩家根据被打出的牌，在限时窗口内选择操作（胡、杠、碰、过）。

    -   服务器根据优先级（胡 > 杠 > 碰）进行仲裁。

    -   **结果**:

        -   **有人胡**: 进入 `HuProcess` 阶段。

        -   **有人杠**: `current_player` 变为杠牌者，进入 `AfterKong` 阶段。

        -   **有人碰**: `current_player` 变为碰牌者，进入 `AfterPong` 阶段。

        -   **无人响应**: `current_player` 轮转至下家，进入 `Draw` 阶段。



6.  **AfterPong 阶段 (碰后)**:

    -   碰牌玩家必须打出一张牌。

    -   进入 `Discard` 阶段。



7.  **AfterKong 阶段 (杠后)**:

    -   杠牌玩家从牌墙末尾补一张牌。

    -   检查是否“杠上花”（自摸）。若是，进入 `HuProcess`。

    -   否则，进入 `Discard` 阶段，杠牌玩家必须打出一张牌。



8.  **HuProcess 阶段 (胡牌处理)**:

    -   计算胡牌番数，结算点炮或自摸所得，并同时结算已产生的杠分。

    -   将胡牌玩家标记为 `is_hu=True`，锁定其暗牌结构：后续摸牌时仅暂存摸入牌并立即打出，不允许选择手牌中其他牌打出。

    -   记录胡牌事件（含番数、来源、被点炮者等信息），供终局汇总。

    -   若牌墙仍有剩余，则轮转至下一位玩家进入 `Draw` 阶段（胡牌者仍在顺序中，会按锁定规则摸打一张牌）；若牌墙耗尽则进入 `EndRound`。



9.  **EndRound 阶段**: 游戏结束，进行最终结算。

**逻辑验证点**：事件优先级确保 Hu 不被抢（例如打出牌后先统一检查 Hu，再处理杠）。`last_hu_fan`（若启用漏胡规则）只在同圈内生效，并在玩家摸完并打出所摸之牌后重置。多重响应冲突使用 FIFO + 优先级队列解决（Hu 拥有最高优先级），同时需确保锁定状态下的玩家只能打出刚摸入的牌。

**展开讨论**：血战模式下，已胡玩家仍需留在循环中以执行“摸一张 → 若可胡则宣胡，否则打出该张”的流程。若牌墙提前耗尽，立即进入 `EndRound`；`wall_size` 持续监控剩余牌量，保障终局触发准确。

### 3.2 碰/杠/胡后的精确逻辑

本节明确定义碰牌、杠牌、胡牌后的操作流程，包括是否摸牌、是否打牌、回合归属等核心逻辑。

#### 3.2.1 碰牌（PONG）后的逻辑

**执行步骤**：
1. 碰牌玩家从手牌中移除2张相同的牌
2. 加上打牌者打出的1张，形成3张明牌（Meld），添加到 `melds` 列表
3. **当前回合切换到碰牌者**（`current_player = pong_player_index`）
4. **碰牌者不摸牌**，直接进入 `AfterPong` 阶段
5. 碰牌者**必须立即打出一张牌**，进入 `Discard` 阶段

**手牌数量变化**：
- 碰牌前：10张暗牌（假设闲家）
- 移除2张 → 8张暗牌
- 直接打出1张 → 7张暗牌（+ 1组3张明牌）

**逻辑验证点**：碰牌后不摸牌是关键点，这使得碰牌玩家的暗牌数减少。

---

#### 3.2.2 杠牌（KONG）后的逻辑

##### 明杠（KONG_EXPOSED - 别人打出的牌）

**执行步骤**：
1. 杠牌玩家从手牌中移除3张相同的牌
2. 加上打牌者打出的1张，形成4张明牌（Meld），添加到 `melds` 列表
3. **立即从牌墙末尾补摸1张牌**（`wall.pop()` 从尾部）
4. **执行刮风下雨结算**：打牌者扣 `2 * base_score` 分，杠牌者加 `2 * base_score` 分
5. **当前回合切换到杠牌者**（`current_player = kong_player_index`）
6. 进入 `AfterKong` 阶段
7. 检查是否"杠上花"（自摸胡牌），若是则进入 `HuProcess`
8. 否则，杠牌者**必须打出一张牌**，进入 `Discard` 阶段

**手牌数量变化**：
- 杠牌前：10张暗牌（假设闲家）
- 移除3张 → 7张暗牌
- 补摸1张 → 8张暗牌
- 打出1张 → 7张暗牌（+ 1组4张明牌）

##### 暗杠（KONG_CONCEALED - 自己手里4张）

**执行步骤**：
1. 在自己回合，手牌中有4张相同的牌
2. 声明暗杠，从手牌移除4张，形成暗杠明牌（Meld），添加到 `melds` 列表
3. **立即从牌墙末尾补摸1张牌**
4. **执行刮风下雨结算**：其他三家各扣 `1 * base_score` 分，杠牌者加 `3 * base_score` 分
5. **当前回合仍是自己**（`current_player` 不变）
6. 进入 `AfterKong` 阶段
7. 检查是否"杠上花"，若是则进入 `HuProcess`
8. 否则，玩家**必须打出一张牌**，进入 `Discard` 阶段

**手牌数量变化**（假设庄家）：
- 轮到自己，已摸牌 → 11张暗牌
- 暗杠移除4张 → 7张暗牌
- 补摸1张 → 8张暗牌
- 打出1张 → 7张暗牌（+ 1组4张暗杠明牌）

**逻辑验证点**：
- 杠牌必定补摸1张，确保玩家有牌可打
- 杠分即时结算（刮风下雨），记录在 `kong_payments` 中
- 杠上花时，补摸的牌若能胡，立即进入 `HuProcess`，不再打牌

##### 杠牌在胡牌判定中的本质（核心概念）

**重要约束**：
- 在**胡牌判定**层面，杠（4张）= 刻子（3张），都是一个面子
- 例如：`11 + 2222 + 3333 + 4444` 等价于 `11 + 222 + 333 + 444`（一对将 + 三个面子）
- **第4张牌不影响牌型结构**，只影响番数（带根，每根+1番）

**实现指导**：
1. **胡牌检查**（`WinChecker.is_hu`）：
   - 杠和刻子等价，都计为"3张或4张相同牌"
   - 牌型结构：一对将（2张）+ 三个面子（每个面子3或4张）
   - 不需要单独处理杠，统一按"相同牌计数"处理

2. **番数计算**（`Scorer.calculate_score`）：
   - 只有4张的才算"带根"（+1番）
   - 明杠、暗杠不影响胡牌判定，只影响番数加成

3. **杠操作的实际作用**：
   - ①即时得分（刮风下雨）：明杠±2分，暗杠/补杠±3分
   - ②补摸牌：可能形成杠上花（+1番）
   - ③战术价值：改变摸牌顺序，暴露/隐藏信息

**避免错误**：
- ❌ 不要在胡牌判定时单独处理杠（会导致逻辑复杂化）
- ❌ 不要认为4张牌会影响手牌数量限制（杠后回合结束时仍是10张暗牌）
- ✅ 将杠理解为"带分数加成的刻子"

---

#### 3.2.3 胡牌（HU）后的逻辑

##### 点炮胡（别人打出的牌）

**执行步骤**：
1. 验证玩家可以胡牌（`WinChecker.is_hu(player, discarded_tile)`）
2. 计算番数（`Scorer.calculate_score(...)`）
3. **结算得分**：点炮者扣 `total_fan` 分，胡牌者加 `total_fan` 分
4. 胡的牌加入 `hu_tiles` 列表（用于显示，不在手牌中）
5. 玩家标记为 `is_hu = True`
6. **不打牌，该玩家的这个回合结束**
7. **游戏继续，轮到打牌者的下一个玩家**（`current_player = (discard_player_index + 1) % 4`）
8. 若牌墙为空，进入 `EndRound`；否则进入 `Draw` 阶段

**手牌数量变化**：
- 手牌保持10张暗牌（胡的牌不加入手牌，而是加入 `hu_tiles`）
- `hu_tiles` = [刚胡的牌]

##### 自摸胡（自己摸到的牌）

**执行步骤**：
1. 验证玩家可以胡牌（`WinChecker.is_hu(player, extra_tile=None)`）
2. 计算番数，叠加"自摸"番（+1番）
3. **结算得分**：其他三家各扣 `total_fan` 分，胡牌者加 `3 * total_fan` 分
4. 摸到的牌从手牌移除，加入 `hu_tiles` 列表
5. 玩家标记为 `is_hu = True`
6. **不打牌，该玩家的这个回合结束**
7. **游戏继续，轮到下一个玩家**（`current_player = (current_player_index + 1) % 4`）
8. 若牌墙为空，进入 `EndRound`；否则进入 `Draw` 阶段

**手牌数量变化**：
- 摸牌后11张 → 移除胡的牌 → 剩10张暗牌
- `hu_tiles` = [刚胡的牌]

**逻辑验证点**：
- 胡牌后不打牌，直接轮到下一个玩家
- 胡的牌存储在 `hu_tiles` 中，用于显示和记录
- 自摸时需要将摸到的牌从手牌中移除，避免手牌数量异常

---

#### 3.2.4 血战到底：已胡玩家继续游戏

**已胡玩家后续行为**：
1. ✅ **可以继续摸牌和打牌**
2. ✅ **可以再次胡牌**（二次胡、三次胡...）
3. ❌ **不能碰牌**（手牌已锁定，代码验证：`if player.is_hu: raise InvalidActionError`）
4. ❌ **不能杠牌**（手牌已锁定）
5. ⚠️  **必须"摸什么打什么"**（不能重新排列手牌，代码验证：`if tile != player.last_drawn_tile: raise InvalidActionError`）

**再次胡牌时**：
- 新胡的牌追加到 `hu_tiles` 列表
- 例如：第一次胡了万7，第二次胡了万4
- `hu_tiles` = [万7, 万4]（是"或"的关系，表示这两张牌都可以胡，不是"与"）
- 手牌数量继续减少：每胡一次，暗牌减1张

**逻辑验证点**：
- 已胡玩家仍在 `current_player` 轮转中，不能跳过
- 摸牌后设置 `last_drawn_tile`，打牌时验证是否是刚摸的牌
- 再次胡牌时，番数重新计算，得分即时结算

---

### 3.3 特殊事件处理
- **天胡**：庄家执行埋牌操作后，检查其剩余的11张手牌。`PatternChecker(hand[dealer], melds, null)` 若为真，则构成天胡。
- **地胡**：闲家执行埋牌操作后，在其第一个摸牌轮次，摸入一张牌后。检查其手牌（10张+1张摸入）是否构成胡牌牌型。
- **杠上花**：Kong后Draw：if supplemental and self_hu: fan+=1。
- **杠上炮**：Kong后Discard：响应Hu时 if last_event==Kong: fan+=1。
- **海底捞月**：Draw时 if wall_size==0 (摸牌前判断，即摸的是最后一张牌): hu时 fan+=1。


**逻辑验证点**：特殊胡叠加到总fan，不改变基本牌型。边缘case：天胡+清一色？计算器先基本再+5。

## 4. 胡牌判断算法

### 4.1 牌型检查原理
输入：hand + melds + extra_tile。输出：can_hu (bool), patterns (List<string>)。

1. **预处理**：
   - `total_tiles` = hand + flatten(melds) + extra。
   - `suits_used` = unique suits in `total_tiles`；if >2: return false (不缺门)。
   - `count[3][10]` = 0；for each tile: `count[suit][rank]++`。

2. **结构化牌型匹配**：
   - **核心思想**：胡牌结构为“一对将 + 三个面子”。算法通过尝试移除一对将，然后检查剩余的牌是否能分解为三个面子（顺子、刻子或杠）来验证。
   - **步骤**：
     a. 遍历`total_tiles`中所有牌，尝试每一种可能成为“将”的组合（`count[s][r] >= 2`）。
     b. 对于每一个候选的“将”，从`count`中移除这两张牌，得到一个临时的`temp_count`。
     c. 调用递归函数`check_sets(temp_count)`，判断剩余的牌是否能分解为三组面子。
   - **递归函数 `check_sets(counts)`**：
     - **Base Case**: 如果牌数为0，说明分解成功，返回`true`。
     - **Recursive Step**:
       - 优先尝试移除一个“杠”（`count[s][r] == 4`），然后递归调用`check_sets`。
       - 再尝试移除一个“刻子”（`count[s][r] >= 3`），然后递归调用`check_sets`。
       - 最后尝试移除一个“顺子”（`count[s][r]`, `[r+1]`, `[r+2]`均`>= 1`），然后递归调用`check_sets`。
     - 如果以上尝试都失败，返回`false`。

3. **番型计算**：
   - 根据成功分解出的面子组合（例如全是刻子/杠，则为“对对胡”），确定基础牌型。
   - 叠加计算门清、自摸、带根等附加番。
   - `total_fan` = `base_fan` + `addon_fan`。

**逻辑验证点**：此算法不再依赖固定的总牌数，而是验证牌型结构。一个杠被视为一个4张的“面子”。这统一了所有胡牌情况，无论是11张、12张还是更多。备忘录（Memoization）可用于优化递归性能。

## 5. 计分与结算算法

### 5.1 即时结算
- **Kong**：Ming: payer (discard_player) score -=2*base；kong_player +=2*base。
  - An/Bu: each other score -=1*base；kong_player +=3*base。
  - Add to kong_payments。
- **Hu**：`total_fan = Scorer.calculate_score(...)`，番数即为记分单位。
  - **自摸**：其余三家各扣 `total_fan` 分，胡牌玩家加 `3 * total_fan` 分（庄家不再额外加倍）。
  - **点炮**：点炮者扣 `total_fan` 分，胡牌玩家加相同分数。
  - **杠上炮**：视为点炮，支付方为被杠者。

### 5.2 局末结算
- Update dealer: 在一炮多响的情况下，由第一个胡牌的玩家坐庄。其他情况（闲家胡牌、庄家胡牌、流局）按标准规则延续。
- Total score accumulate。

**逻辑验证点**：base=1默认。公式精确：self = fan_base *3 - kongs owed。边缘case：多胡分摊？一人点炮多付。

## 6. 游戏结束处理算法

1. **触发条件**：`wall_size == 0`（牌墙摸完）。
2. **结算步骤**：
   - 统计所有玩家的得分（包括胡牌得分和杠分）。
   - 杠分在发生时已即时结算（刮风下雨），无需额外处理。
   - 不执行查花猪、查大叫等额外流程。
3. **最终分数**：所有玩家的当前 `score` 即为最终积分。

**逻辑验证点**：游戏仅在牌墙摸完时结束，无论是否有玩家胡牌。已胡玩家的得分和杠分已在游戏过程中实时结算完成。

## 7. 整体架构与扩展性

- **FSM**：switch(state) drive loop；events decouple (e.g., UI subscribe)。
- **AI**：使用固定优先级策略（Hu > Kong > Pong > Pass），后续可替换为更复杂的评估函数。
- **Test**：固定随机种子回放，断言 `EndRound` 仅在牌墙耗尽或显式终止时触发，并验证已胡牌玩家不会再次摸牌或出牌。
- **扩展**：可参数化番数权重、定缺张数等配置；当前埋数固定为 3。
