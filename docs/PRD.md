# 血战到底麻将 - 后端服务产品需求文档 (PRD)

## 1. 概述

### 1.1. 项目目标
本项目旨在为“血战到底”麻将游戏构建一个稳定、高效且模块化的后端服务。该服务将独立处理所有游戏核心逻辑，包括规则判断、状态管理、计分结算等，并通过一组清晰的API接口与前端或其他客户端进行交互。

### 1.2. 核心特点
- **血战到底模式**：牌局仅在牌墙摸完后结束；玩家第一次胡牌后暗牌结构锁定，但仍需参与后续摸打，且必须“摸什么打什么”，仍可继续自摸或点炮胡牌。
- **定缺埋牌**：开局时玩家需选择一门花色作为缺门，并埋下三张同花色的牌。
- **结构化胡牌**：胡牌牌型统一为“一对将 + 三个面子”，移除了七对等特殊牌型，规则更清晰。
- **简化计分**：最终得分直接等于番数，取消传统的指数倍数换算，降低学习成本。
- **真人 + AI 流程**：默认 1 名真人对战 3 名 AI，AI 即刻响应，真人玩家可以自由思考。
- **模块化API**：后端功能通过模块化接口暴露，便于前端接入和未来扩展。

---

## 2. 核心游戏规则

这是后端逻辑必须严格遵守的规则集，是所有算法实现的基础。

### 2.1. 游戏准备
- **玩家人数**：4人。
- **牌库**：使用筒、条、万三种花色，每种1-9各4张，共108张牌。
- **发牌**：庄家起手14张，闲家13张。

### 2.2. 定缺埋牌
- **动作**：发牌后，每位玩家必须从手牌中选择三张同花色的牌进行“埋牌”。
- **效果**：
  - 埋下的牌亮明缺门，但不参与后续牌局。
  - 埋牌后，庄家手牌变为11张，闲家变为10张。
  - 玩家在后续出牌时，必须优先打完缺门花色的牌。

### 2.3. 游戏流程
- **禁止吃牌**：不允许“吃”操作。
- **碰牌**：任意玩家打出的牌，如有玩家手中有两张相同的牌，可碰。
- **杠牌**：
  - **明杠**：手中有三张相同牌，他人打出第四张时可杠。点杠者向杠牌者支付2倍底分。
  - **暗杠**：手中有四张相同牌，可声明杠牌。其他三家向杠牌者各支付1倍底分。
  - **补杠**：已碰牌后，自己摸到第四张相同的牌，可杠。其他三家向杠牌者各支付1倍底分。
- **缺门优先**：若手牌仍有缺门花色，玩家必须优先打出这些牌。
- **回合节奏**：真人玩家可自由思考；AI 对弃牌或系统事件即时给出响应，系统不设 5 秒等候或超时处理。
- **血战流程**：玩家第一次胡牌后，暗牌结构锁定，不得自行重排；后续仍按顺序摸牌并立即打出所摸之牌，可在摸牌瞬间自摸，也可对他人弃牌继续宣胡。牌局一直持续到牌墙摸完。

### 2.4. 胡牌条件
- **缺门**：胡牌时，玩家的手牌和明牌中不能包含自己已定缺的花色。
- **牌型结构**：胡牌牌型必须由 **“一对将”** 和 **“三个面子”** 组成。
  - **将**：两张相同的牌。
  - **面子**：可以是“顺子”（三张连续的牌）、“刻子”（三张相同的牌）或“杠”（四张相同的牌）。
- **手牌张数约束**：当轮到玩家行动时，庄家最多持有14张牌、闲家最多13张。执行明杠/暗杠/补杠会先将4张牌移出手牌形成明牌，再补摸1张牌，因此手牌张数从“原始张数”减3，仍不超过上述上限。由此可知，即便连续杠牌，暗牌数量也不会超过14张。

### 2.5. 计分规则
- **总番即得分**：胡牌后计算出的总番数就是记分单位，不再对底分做指数扩张。点炮时由点炮者支付该番数；自摸时其余三家各支付该番数。
- **基础番数**：满足胡牌条件即得 1 番，以下番型在满足条件时按表格累加。
- **主要番型（可叠加时列示贡献）**：

| 牌型名称 | 番数贡献 | 描述 |
|---|---|---|
| 基本胡 | 1 | 满足胡牌结构和缺门要求 |
| 门清 | +1 | 未碰、未执行明杠或补杠；暗杠不破坏门清 |
| 自摸 | +1 | 自己摸牌胡 |
| 带根（每根）| +1 | 每组四张同牌（刻子/杠）算一根 |
| 对对胡 | +1 | 三副刻子/杠组合成的胡牌 |
| 清一色 | +2 | 所有牌为同一花色 |
| 金钩钓 | +1 | 胡牌时暗牌仅剩 1 张 |
| 清金钩钓 | +4 | 同时满足清一色与金钩钓 |
| 天胡/地胡 | +5 | 庄家埋牌后直接胡/闲家第一轮摸牌即胡 |
| 杠上花 / 杠上炮 | +1 | 杠后立即胡牌 |
| 海底捞月 | +1 | 摸最后一张牌胡 |

- **杠分结算**：所有杠分在发生时即时结算（“刮风下雨”），结算时记入双方分数账面。

### 2.6. 游戏结束
- **结束条件**：游戏在牌墙摸完时结束，无论是否有玩家胡牌。
- **最终结算**：统计所有玩家的得分（包括胡牌得分和杠分），生成最终积分。杠分在发生时已即时结算。

---

## 3. 模块化接口设计 (API)

后端服务应至少包含以下两大核心模块，并通过API暴露其功能。

### 3.1. 游戏管理模块 (`GameManager`)
负责管理一整局游戏的生命周期。
- `create_game(players)`: 创建一个新游戏，初始化牌墙、玩家等。
- `start_game()`: 宣布游戏开始，进入发牌和定缺阶段。
- `get_game_state(player_id)`: 获取当前游戏状态。为保证信息安全，应根据`player_id`过滤信息，例如只向该玩家展示其手牌。
- `end_game()`: 游戏结束，进行最终结算。

### 3.2. 玩家动作模块 (`PlayerActions`)
负责处理来自玩家的每一个具体操作。
- `bury_cards(player_id, tiles)`: 处理玩家的埋牌定缺操作。
- `discard_tile(player_id, tile)`: 处理玩家的出牌操作。
- `declare_action(player_id, action_type, target_tile)`: 处理玩家针对其他玩家出牌的响应，如 `action_type` 可以是 `PONG`, `KONG`, `HU`, `PASS`。

### 3.3. 并发与响应处理
- **响应收集**：AI 玩家即时返回碰/杠/胡/过的决策，系统按顺序收集结果。
- **真人交互**：单一真人玩家自行决定出牌节奏，不设置等待或超时机制。
- **优先级仲裁**：对同一张弃牌的所有响应按照 `胡 > 杠 > 碰 > 过` 的优先级逐一裁定。

---

## 4. 核心数据结构

API交互中需要用到的主要数据对象。

- **`GameState`**: 描述游戏全局状态。
  - `game_id`: 游戏唯一标识。
  - `players`: 玩家列表。
  - `current_player_index`: 当前轮到哪个玩家操作。
  - `wall_remaining_count`: 牌墙剩余张数。
  - `public_discards`: 公共弃牌堆。
  - `game_phase`: 游戏当前阶段（如 `BURYING`, `PLAYING`, `ENDED`）。

- **`Player`**: 描述单个玩家的状态。
  - `player_id`: 玩家唯一标识。
  - `hand`: 手牌列表（对其他玩家不可见）。
  - `melds`: 碰或杠的明牌。
  - `buried_cards`: 埋下的三张牌。
  - `missing_suit`: 缺门花色。
  - `score`: 当前积分。
  - `is_hu`: 是否已胡牌。

- **`Tile`**: 描述一张麻将牌。
  - `suit`: 花色（筒、条、万）。
  - `rank`: 点数（1-9）。

---

## 5. 暂不实现 (Out of Scope)

为保证项目初期聚焦核心逻辑，以下功能暂不实现：
- **高级 AI 策略**：仅提供基础响应逻辑，不追求复杂博弈或深度学习算法。
- **用户认证与账户系统**：玩家通过临时`player_id`加入游戏。
- **数据持久化**：游戏状态仅在内存中管理，服务重启后游戏消失。
- **前端UI**：本项目只负责后端逻辑。
