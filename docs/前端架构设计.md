# 血战到底麻将前端架构设计文档

## 文档版本
- **版本号**: v1.0
- **创建日期**: 2025-11-05
- **最后更新**: 2025-11-05

---

## 1. 架构概览

### 1.1 整体架构
```
┌─────────────────────────────────────────────────────────┐
│                    Browser (浏览器)                      │
├─────────────────────────────────────────────────────────┤
│                    Frontend (React)                      │
│  ┌────────────────────────────────────────────────────┐ │
│  │  Presentation Layer (展示层)                       │ │
│  │  - React Components (UI组件)                      │ │
│  │  - Canvas Renderers (Canvas渲染器)               │ │
│  └─────────────┬──────────────────────────────────────┘ │
│                ↓                                         │
│  ┌────────────────────────────────────────────────────┐ │
│  │  State Management Layer (状态管理层)              │ │
│  │  - Zustand Stores (全局状态)                      │ │
│  │  - TanStack Query (服务器状态缓存)               │ │
│  └─────────────┬──────────────────────────────────────┘ │
│                ↓                                         │
│  ┌────────────────────────────────────────────────────┐ │
│  │  Business Logic Layer (业务逻辑层)                │ │
│  │  - Game Hooks (游戏逻辑Hooks)                     │ │
│  │  - Utils (工具函数)                               │ │
│  └─────────────┬──────────────────────────────────────┘ │
│                ↓                                         │
│  ┌────────────────────────────────────────────────────┐ │
│  │  Data Access Layer (数据访问层)                   │ │
│  │  - API Services (API服务)                         │ │
│  │  - Axios Client (HTTP客户端)                      │ │
│  └─────────────┬──────────────────────────────────────┘ │
└────────────────┼──────────────────────────────────────┘
                 ↓ RESTful API (轮询)
┌─────────────────────────────────────────────────────────┐
│              Backend (Python FastAPI)                    │
│              - Game Logic (游戏逻辑)                     │
│              - AI (电脑玩家)                             │
└─────────────────────────────────────────────────────────┘
```

### 1.2 核心设计原则
- ✅ **分层解耦**：展示层、状态层、逻辑层、数据层职责清晰
- ✅ **单向数据流**：数据从上到下流动，事件从下到上冒泡
- ✅ **组件化**：高内聚、低耦合，可复用
- ✅ **类型安全**：TypeScript全覆盖，前后端类型共享
- ✅ **测试友好**：逻辑与UI分离，便于单元测试

### 1.3 项目约束与近期结论
- **单仓结构**：前后端统一保存在本仓库，前端代码位于 `frontend/` 目录，提交时可以同时更新接口与界面，方便单人开发与回滚。
- **资源策略**：MVP 阶段全部麻将牌与界面装饰均由 Canvas 程序化绘制（矩形、渐变、文字），无需外部精灵图或设计稿；若未来需要美化，可在同一绘制管线中替换为 sprite sheet。
- **玩法驱动**：默认 1 名真人 + 3 名内置 AI。真人通过图形界面触发 `/create`→`/bury`→`/action`，后端在同一进程中同步推进 AI 回合；如需显式触发，可在检测到 `currentPlayer !== 0` 时调用 `/api/game/{id}/ai/step`，但始终围绕单人推进体验。
- **运行假设**：仅支持本机调试，不考虑多线程、高可用、鉴权或安全策略；所有游戏状态驻留于 FastAPI 进程内存，追求“能玩、易调试”。
- **语言与文案**：界面、提示、日志全部使用中文，不引入 i18n 库，字符串可直接写在组件或常量文件中。

---

## 2. 目录结构设计

### 2.1 完整目录树
```
frontend/
├── public/                          # 静态资源
│   ├── assets/                      # 游戏资源
│   │   ├── tiles/                   # 麻将牌图片
│   │   │   ├── sprite-sheet.png     # 精灵图（所有牌）
│   │   │   └── sprite-sheet.json    # 精灵图坐标定义
│   │   ├── bg.jpg                   # 游戏背景
│   │   └── logo.svg                 # Logo
│   └── favicon.ico
│
├── src/
│   ├── main.tsx                     # 应用入口
│   ├── App.tsx                      # 根组件
│   ├── vite-env.d.ts                # Vite类型定义
│   │
│   ├── components/                  # UI组件
│   │   ├── common/                  # 通用组件
│   │   │   ├── Button.tsx
│   │   │   ├── Modal.tsx
│   │   │   └── Toast.tsx
│   │   │
│   │   ├── game/                    # 游戏组件
│   │   │   ├── GameBoard.tsx        # 游戏面板（容器）
│   │   │   ├── PlayerHand.tsx       # 玩家手牌区域
│   │   │   ├── AIPlayer.tsx         # AI玩家区域
│   │   │   ├── DiscardPile.tsx      # 弃牌堆
│   │   │   ├── ActionButtons.tsx    # 操作按钮组（碰/杠/胡）
│   │   │   └── GameInfo.tsx         # 游戏信息栏
│   │   │
│   │   └── canvas/                  # Canvas渲染组件
│   │       ├── TileCanvas.tsx       # 麻将牌Canvas容器
│   │       └── BoardCanvas.tsx      # 游戏桌面Canvas
│   │
│   ├── stores/                      # Zustand状态管理
│   │   ├── gameStore.ts             # 游戏状态
│   │   ├── uiStore.ts               # UI状态（模态框、提示等）
│   │   └── index.ts                 # 统一导出
│   │
│   ├── hooks/                       # 自定义Hooks
│   │   ├── useGameState.ts          # 游戏状态Hook（轮询）
│   │   ├── usePlayerAction.ts       # 玩家操作Hook
│   │   ├── useTileSelection.ts      # 手牌选择Hook
│   │   └── useCanvas.ts             # Canvas渲染Hook
│   │
│   ├── services/                    # API服务层
│   │   ├── api/
│   │   │   ├── gameApi.ts           # 游戏API
│   │   │   ├── playerApi.ts         # 玩家API
│   │   │   └── index.ts
│   │   └── apiClient.ts             # Axios配置
│   │
│   ├── types/                       # TypeScript类型定义
│   │   ├── game.ts                  # 游戏相关类型
│   │   ├── tile.ts                  # 麻将牌类型
│   │   ├── api.ts                   # API请求/响应类型
│   │   └── index.ts
│   │
│   ├── utils/                       # 工具函数
│   │   ├── tileUtils.ts             # 麻将牌工具（排序、比较）
│   │   ├── canvasUtils.ts           # Canvas工具（绘制、坐标转换）
│   │   ├── constants.ts             # 常量定义
│   │   └── helpers.ts               # 通用辅助函数
│   │
│   ├── renderers/                   # Canvas渲染器（业务逻辑）
│   │   ├── TileRenderer.ts          # 麻将牌渲染器
│   │   ├── BoardRenderer.ts         # 游戏桌面渲染器
│   │   └── AnimationManager.ts      # 动画管理器（可选）
│   │
│   └── styles/                      # 全局样式
│       ├── index.css                # Tailwind入口 + 全局样式
│       └── variables.css            # CSS变量
│
├── index.html                       # HTML模板
├── package.json
├── tsconfig.json                    # TypeScript配置
├── vite.config.ts                   # Vite配置
├── tailwind.config.js               # Tailwind配置
├── eslint.config.js                 # ESLint配置
├── .prettierrc                      # Prettier配置
└── README.md
```

---

## 3. 核心模块设计

### 3.1 类型定义 (`types/`)

#### 3.1.1 麻将牌类型 (`tile.ts`)
```typescript
/**
 * 花色枚举
 */
export enum Suit {
  WAN = 'wan',    // 万
  TIAO = 'tiao',  // 条
  TONG = 'tong'   // 筒
}

/**
 * 麻将牌定义
 */
export interface Tile {
  suit: Suit
  rank: 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
  id?: string  // 前端用于追踪（可选）
}

/**
 * 面子类型（碰/杠的明牌）
 */
export enum MeldType {
  PONG = 'pong',      // 碰（3张）
  KONG = 'kong',      // 杠（4张）
  CHOW = 'chow'       // 吃（MVP不支持）
}

export interface Meld {
  type: MeldType
  tiles: Tile[]
}
```

#### 3.1.2 游戏状态类型 (`game.ts`)
```typescript
import { Tile, Meld, Suit } from './tile'

/**
 * 游戏阶段
 */
export enum GamePhase {
  INIT = 'INIT',           // 初始化
  BURYING = 'BURYING',     // 定缺埋牌
  PLAYING = 'PLAYING',     // 游戏中
  RESPONDING = 'RESPONDING', // 等待响应（碰/杠/胡）
  ENDED = 'ENDED'          // 游戏结束
}

/**
 * 动作类型
 */
export enum ActionType {
  DISCARD = 'DISCARD',  // 出牌
  PONG = 'PONG',        // 碰
  KONG = 'KONG',        // 杠
  HU = 'HU',            // 胡
  PASS = 'PASS'         // 过
}

/**
 * AI玩家信息（对玩家隐藏手牌）
 */
export interface AIPlayer {
  id: number
  handCount: number      // 手牌数量
  melds: Meld[]          // 明牌
  buried: Tile[]         // 埋牌（公开）
  missingSuit: Suit | null  // 缺门
  score: number
}

/**
 * 游戏状态（前端视角）
 */
export interface GameState {
  gameId: string
  phase: GamePhase
  currentPlayer: number  // 0=玩家, 1-3=AI
  dealer: number         // 庄家

  // 玩家信息
  playerHand: Tile[]
  playerMelds: Meld[]
  playerBuried: Tile[]
  playerMissingSuit: Suit | null
  playerScore: number

  // AI玩家
  aiPlayers: AIPlayer[]

  // 公共信息
  discardPile: Tile[]       // 弃牌堆
  lastDiscard: Tile | null  // 最新打出的牌
  wallRemaining: number     // 牌墙剩余

  // 可用动作
  availableActions: ActionType[]

  // 游戏结果（结束时）
  winner?: number           // 胡牌者ID
  winType?: 'SELF_DRAW' | 'DISCARD'  // 自摸/点炮
  scoreChanges?: Record<number, number>  // 积分变化
}
```

#### 3.1.3 API类型 (`api.ts`)
```typescript
import { Tile, ActionType, GameState } from './index'

// ========== 请求类型 ==========

export interface CreateGameRequest {
  playerName?: string  // 可选
}

export interface BuryCardsRequest {
  gameId: string
  tiles: Tile[]  // 3张同花色
}

export interface PlayerActionRequest {
  gameId: string
  action: ActionType
  tile?: Tile  // DISCARD时必填
}

export interface AIStepRequest {
  gameId: string
}

// ========== 响应类型 ==========

export interface ApiResponse<T = unknown> {
  success: boolean
  data?: T
  error?: {
    code: string
    message: string
  }
}

export type CreateGameResponse = ApiResponse<{
  gameId: string
  state: GameState
}>

export type GameStateResponse = ApiResponse<GameState>

export type ActionResponse = ApiResponse<{
  state: GameState
  message?: string  // "碰牌成功"等提示
}>
```

---

### 3.2 状态管理 (`stores/`)

#### 3.2.1 游戏状态 (`gameStore.ts`)
```typescript
import { create } from 'zustand'
import { GameState, Tile } from '@/types'

interface GameStore extends GameState {
  // Actions
  setGameState: (state: Partial<GameState>) => void
  updatePlayerHand: (tiles: Tile[]) => void
  addToDiscardPile: (tile: Tile) => void
  reset: () => void
}

const initialState: GameState = {
  gameId: '',
  phase: 'INIT',
  currentPlayer: 0,
  dealer: 0,
  playerHand: [],
  playerMelds: [],
  playerBuried: [],
  playerMissingSuit: null,
  playerScore: 0,
  aiPlayers: [],
  discardPile: [],
  lastDiscard: null,
  wallRemaining: 108,
  availableActions: []
}

export const useGameStore = create<GameStore>((set) => ({
  ...initialState,

  setGameState: (newState) => set((state) => ({ ...state, ...newState })),

  updatePlayerHand: (tiles) => set({ playerHand: tiles }),

  addToDiscardPile: (tile) => set((state) => ({
    discardPile: [...state.discardPile, tile],
    lastDiscard: tile
  })),

  reset: () => set(initialState)
}))
```

#### 3.2.2 UI状态 (`uiStore.ts`)
```typescript
import { create } from 'zustand'

interface UIStore {
  // 选中的手牌（用于埋牌、出牌）
  selectedTiles: string[]  // Tile IDs

  // 模态框
  isModalOpen: boolean
  modalContent: React.ReactNode | null

  // Toast提示
  toastMessage: string | null
  toastType: 'success' | 'error' | 'info'

  // 加载状态
  isLoading: boolean

  // Actions
  selectTile: (tileId: string) => void
  deselectTile: (tileId: string) => void
  clearSelection: () => void
  openModal: (content: React.ReactNode) => void
  closeModal: () => void
  showToast: (message: string, type: 'success' | 'error' | 'info') => void
  hideToast: () => void
  setLoading: (loading: boolean) => void
}

export const useUIStore = create<UIStore>((set) => ({
  selectedTiles: [],
  isModalOpen: false,
  modalContent: null,
  toastMessage: null,
  toastType: 'info',
  isLoading: false,

  selectTile: (id) => set((state) => ({
    selectedTiles: [...state.selectedTiles, id]
  })),

  deselectTile: (id) => set((state) => ({
    selectedTiles: state.selectedTiles.filter((tid) => tid !== id)
  })),

  clearSelection: () => set({ selectedTiles: [] }),

  openModal: (content) => set({ isModalOpen: true, modalContent: content }),

  closeModal: () => set({ isModalOpen: false, modalContent: null }),

  showToast: (message, type) => set({ toastMessage: message, toastType: type }),

  hideToast: () => set({ toastMessage: null }),

  setLoading: (loading) => set({ isLoading: loading })
}))
```

---

### 3.3 API服务层 (`services/`)

#### 3.3.1 Axios配置 (`apiClient.ts`)
```typescript
import axios from 'axios'

export const apiClient = axios.create({
  baseURL: import.meta.env.VITE_API_BASE_URL || 'http://localhost:8000',
  timeout: 10000,
  headers: {
    'Content-Type': 'application/json'
  }
})

// 请求拦截器
apiClient.interceptors.request.use(
  (config) => {
    console.log('API Request:', config.method?.toUpperCase(), config.url)
    return config
  },
  (error) => Promise.reject(error)
)

// 响应拦截器
apiClient.interceptors.response.use(
  (response) => response.data,  // 直接返回data
  (error) => {
    console.error('API Error:', error)
    return Promise.reject(error)
  }
)
```

#### 3.3.2 游戏API (`services/api/gameApi.ts`)
```typescript
import { apiClient } from '../apiClient'
import {
  CreateGameRequest,
  CreateGameResponse,
  GameStateResponse,
  PlayerActionRequest,
  ActionResponse,
  BuryCardsRequest
} from '@/types/api'

export const gameApi = {
  /**
   * 创建游戏
   */
  createGame: async (req: CreateGameRequest): Promise<CreateGameResponse> => {
    return apiClient.post('/api/game/create', req)
  },

  /**
   * 获取游戏状态
   */
  getGameState: async (gameId: string): Promise<GameStateResponse> => {
    return apiClient.get(`/api/game/${gameId}/state`)
  },

  /**
   * 埋牌定缺
   */
  buryCards: async (req: BuryCardsRequest): Promise<ActionResponse> => {
    return apiClient.post(`/api/game/${req.gameId}/bury`, {
      tiles: req.tiles
    })
  },

  /**
   * 玩家动作
   */
  playerAction: async (req: PlayerActionRequest): Promise<ActionResponse> => {
    return apiClient.post(`/api/game/${req.gameId}/action`, {
      action: req.action,
      tile: req.tile
    })
  },

  /**
   * 触发AI执行一步
   */
  aiStep: async (gameId: string): Promise<ActionResponse> => {
    return apiClient.post(`/api/game/${gameId}/ai/step`)
  }
}
```

---

### 3.4 自定义Hooks (`hooks/`)

#### 3.4.1 游戏状态Hook (`useGameState.ts`)
```typescript
import { useQuery } from '@tanstack/react-query'
import { gameApi } from '@/services/api'
import { useGameStore } from '@/stores/gameStore'
import { useEffect } from 'react'

/**
 * 轮询游戏状态
 * 仅在游戏进行中且轮到AI时轮询
 */
export function useGameState(gameId: string | null) {
  const { phase, currentPlayer, setGameState } = useGameStore()

  const shouldPoll =
    gameId &&
    phase === 'PLAYING' &&
    currentPlayer !== 0  // 不是玩家回合

  const { data, isLoading, error } = useQuery({
    queryKey: ['gameState', gameId],
    queryFn: () => gameApi.getGameState(gameId!),
    enabled: !!gameId,
    refetchInterval: shouldPoll ? 500 : false,  // 500ms轮询
    staleTime: 0  // 始终获取最新数据
  })

  // 同步到Zustand
  useEffect(() => {
    if (data?.success && data.data) {
      setGameState(data.data)
    }
  }, [data, setGameState])

  return { isLoading, error }
}
```

#### 3.4.2 玩家动作Hook (`usePlayerAction.ts`)
```typescript
import { useMutation, useQueryClient } from '@tanstack/react-query'
import { gameApi } from '@/services/api'
import { useGameStore } from '@/stores/gameStore'
import { useUIStore } from '@/stores/uiStore'
import { ActionType, Tile } from '@/types'

export function usePlayerAction() {
  const { gameId } = useGameStore()
  const { showToast } = useUIStore()
  const queryClient = useQueryClient()

  const mutation = useMutation({
    mutationFn: ({ action, tile }: { action: ActionType; tile?: Tile }) =>
      gameApi.playerAction({ gameId: gameId!, action, tile }),

    onSuccess: (response) => {
      if (response.success && response.data) {
        // 更新游戏状态
        queryClient.invalidateQueries({ queryKey: ['gameState', gameId] })

        // 显示提示
        if (response.data.message) {
          showToast(response.data.message, 'success')
        }
      }
    },

    onError: (error: any) => {
      showToast(error.response?.data?.error?.message || '操作失败', 'error')
    }
  })

  return {
    executeAction: mutation.mutate,
    isExecuting: mutation.isPending
  }
}
```

#### 3.4.3 手牌选择Hook (`useTileSelection.ts`)
```typescript
import { useUIStore } from '@/stores/uiStore'
import { Tile } from '@/types'

export function useTileSelection(maxSelection: number = 1) {
  const { selectedTiles, selectTile, deselectTile, clearSelection } = useUIStore()

  const toggleTile = (tile: Tile) => {
    if (!tile.id) return

    if (selectedTiles.includes(tile.id)) {
      deselectTile(tile.id)
    } else if (selectedTiles.length < maxSelection) {
      selectTile(tile.id)
    }
  }

  const isSelected = (tile: Tile) => tile.id && selectedTiles.includes(tile.id)

  return {
    selectedTiles,
    toggleTile,
    isSelected,
    clearSelection,
    canSelectMore: selectedTiles.length < maxSelection
  }
}
```

---

### 3.5 Canvas渲染器 (`renderers/`)

#### 3.5.1 麻将牌渲染器 (`TileRenderer.ts`)
```typescript
import { Tile, Suit } from '@/types'

/**
 * 麻将牌渲染器
 */
export class TileRenderer {
  private canvas: HTMLCanvasElement
  private ctx: CanvasRenderingContext2D
  private spriteSheet: HTMLImageElement | null = null
  private spriteData: Record<string, { x: number; y: number; w: number; h: number }> = {}

  constructor(canvas: HTMLCanvasElement) {
    this.canvas = canvas
    this.ctx = canvas.getContext('2d')!
  }

  /**
   * 加载精灵图
   */
  async loadSpriteSheet(imagePath: string, dataPath: string) {
    // 加载图片
    this.spriteSheet = new Image()
    this.spriteSheet.src = imagePath

    // 加载坐标数据
    const response = await fetch(dataPath)
    this.spriteData = await response.json()

    return new Promise((resolve) => {
      this.spriteSheet!.onload = resolve
    })
  }

  /**
   * 绘制单张牌
   */
  drawTile(tile: Tile, x: number, y: number, width: number, height: number) {
    if (!this.spriteSheet) return

    const key = `${tile.suit}_${tile.rank}`
    const sprite = this.spriteData[key]

    if (!sprite) {
      console.warn(`Sprite not found: ${key}`)
      return
    }

    this.ctx.drawImage(
      this.spriteSheet,
      sprite.x, sprite.y, sprite.w, sprite.h,  // 源坐标
      x, y, width, height                      // 目标坐标
    )
  }

  /**
   * 绘制牌背
   */
  drawTileBack(x: number, y: number, width: number, height: number) {
    const sprite = this.spriteData['back']
    if (this.spriteSheet && sprite) {
      this.ctx.drawImage(
        this.spriteSheet,
        sprite.x, sprite.y, sprite.w, sprite.h,
        x, y, width, height
      )
    }
  }

  /**
   * 绘制手牌（带间距）
   */
  drawHand(tiles: Tile[], startX: number, startY: number, tileWidth: number, tileHeight: number, spacing: number = 5) {
    tiles.forEach((tile, index) => {
      const x = startX + index * (tileWidth + spacing)
      this.drawTile(tile, x, startY, tileWidth, tileHeight)
    })
  }

  /**
   * 清空画布
   */
  clear() {
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height)
  }
}
```

---

### 3.6 组件设计 (`components/`)

#### 3.6.1 游戏面板容器 (`GameBoard.tsx`)
```typescript
import { useEffect } from 'react'
import { useGameStore } from '@/stores/gameStore'
import { useGameState } from '@/hooks/useGameState'
import PlayerHand from './PlayerHand'
import AIPlayer from './AIPlayer'
import DiscardPile from './DiscardPile'
import ActionButtons from './ActionButtons'
import GameInfo from './GameInfo'

export default function GameBoard() {
  const { gameId, phase, aiPlayers } = useGameStore()
  const { isLoading } = useGameState(gameId)

  if (!gameId) {
    return <div>游戏未开始</div>
  }

  return (
    <div className="game-board relative w-full h-screen bg-green-800">
      {/* AI玩家2（上家） */}
      <div className="absolute top-4 left-1/2 -translate-x-1/2">
        <AIPlayer player={aiPlayers[1]} position="top" />
      </div>

      {/* AI玩家3（左） */}
      <div className="absolute left-4 top-1/2 -translate-y-1/2">
        <AIPlayer player={aiPlayers[2]} position="left" />
      </div>

      {/* AI玩家1（右） */}
      <div className="absolute right-4 top-1/2 -translate-y-1/2">
        <AIPlayer player={aiPlayers[0]} position="right" />
      </div>

      {/* 中央弃牌堆 */}
      <div className="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2">
        <DiscardPile />
      </div>

      {/* 操作按钮 */}
      {phase === 'PLAYING' && (
        <div className="absolute bottom-32 left-1/2 -translate-x-1/2">
          <ActionButtons />
        </div>
      )}

      {/* 玩家手牌 */}
      <div className="absolute bottom-4 left-1/2 -translate-x-1/2">
        <PlayerHand />
      </div>

      {/* 游戏信息 */}
      <GameInfo />

      {/* 加载遮罩 */}
      {isLoading && (
        <div className="absolute inset-0 bg-black/50 flex items-center justify-center">
          <div className="text-white">加载中...</div>
        </div>
      )}
    </div>
  )
}
```

#### 3.6.2 玩家手牌 (`PlayerHand.tsx`)
```typescript
import { useGameStore } from '@/stores/gameStore'
import { useTileSelection } from '@/hooks/useTileSelection'
import { usePlayerAction } from '@/hooks/usePlayerAction'
import { Tile } from '@/types'
import clsx from 'clsx'

export default function PlayerHand() {
  const { playerHand, phase } = useGameStore()
  const { toggleTile, isSelected } = useTileSelection(phase === 'BURYING' ? 3 : 1)
  const { executeAction } = usePlayerAction()

  const handleTileClick = (tile: Tile) => {
    if (phase === 'BURYING') {
      toggleTile(tile)
    } else if (phase === 'PLAYING') {
      // 直接出牌
      executeAction({ action: 'DISCARD', tile })
    }
  }

  return (
    <div className="flex gap-2">
      {playerHand.map((tile, index) => (
        <div
          key={tile.id || index}
          className={clsx(
            'tile w-16 h-20 bg-white rounded shadow cursor-pointer',
            'transition-transform hover:-translate-y-2',
            isSelected(tile) && '-translate-y-4 ring-2 ring-yellow-400'
          )}
          onClick={() => handleTileClick(tile)}
        >
          {/* 简化显示：文字 */}
          <div className="flex items-center justify-center h-full text-sm">
            {tile.suit} {tile.rank}
          </div>
        </div>
      ))}
    </div>
  )
}
```

---

## 4. 数据流设计

### 4.1 游戏初始化流程
```
用户点击"开始游戏"
  ↓
调用 gameApi.createGame()
  ↓
后端创建游戏，返回 gameId 和初始状态
  ↓
Zustand.setGameState(response.data)
  ↓
TanStack Query 开始轮询 /api/game/:id/state
  ↓
组件重新渲染，显示手牌
```

### 4.2 玩家出牌流程
```
用户点击手牌
  ↓
usePlayerAction.executeAction({ action: 'DISCARD', tile })
  ↓
调用 gameApi.playerAction()
  ↓
后端执行出牌，currentPlayer 变为 AI
  ↓
前端轮询检测到 currentPlayer !== 0
  ↓
开始高频轮询（500ms）
  ↓
后端AI自动出牌（或前端主动调用 gameApi.aiStep()）
  ↓
轮询获取最新状态，currentPlayer 回到 0
  ↓
停止轮询，等待玩家操作
```

### 4.3 碰牌流程
```
AI出牌
  ↓
后端检测玩家可碰，返回 availableActions: ['PONG', 'PASS']
  ↓
前端显示 [碰] [过] 按钮
  ↓
用户点击 [碰]
  ↓
executeAction({ action: 'PONG' })
  ↓
后端执行碰牌，currentPlayer 变为 0（玩家获得出牌权）
  ↓
前端更新状态，显示明牌，等待玩家出牌
```

---

## 5. 渲染优化策略

### 5.1 Canvas分层
```tsx
<div className="canvas-container relative">
  <canvas id="bg-layer" className="absolute" />     {/* 静态背景 */}
  <canvas id="tiles-layer" className="absolute" /> {/* 麻将牌 */}
  <canvas id="ui-layer" className="absolute" />    {/* 高亮、选中框 */}
</div>
```

### 5.2 离屏Canvas缓存
```typescript
// 预渲染所有牌面到离屏Canvas
const offscreenCanvas = document.createElement('canvas')
const offscreenCtx = offscreenCanvas.getContext('2d')!

// 使用时直接 drawImage
ctx.drawImage(offscreenCanvas, sx, sy, sw, sh, dx, dy, dw, dh)
```

### 5.3 按需重绘
```typescript
// 只重绘变化的牌
function redrawTile(index: number) {
  const tile = playerHand[index]
  const x = startX + index * (tileWidth + spacing)

  // 清除该牌区域
  ctx.clearRect(x, y, tileWidth, tileHeight)

  // 重绘
  tileRenderer.drawTile(tile, x, y, tileWidth, tileHeight)
}
```

---

## 6. 错误处理策略

### 6.1 API错误处理
```typescript
// apiClient.ts 响应拦截器
apiClient.interceptors.response.use(
  (response) => response.data,
  (error) => {
    const message = error.response?.data?.error?.message || '网络错误'

    // 统一Toast提示
    useUIStore.getState().showToast(message, 'error')

    return Promise.reject(error)
  }
)
```

### 6.2 前端校验
```typescript
// 出牌前校验
function validateDiscard(tile: Tile, hand: Tile[], missingSuit: Suit | null) {
  // 检查是否在手牌中
  if (!hand.some(t => t.suit === tile.suit && t.rank === tile.rank)) {
    return { valid: false, message: '牌不在手牌中' }
  }

  // 检查定缺规则
  const hasMissingSuitTiles = hand.some(t => t.suit === missingSuit)
  if (hasMissingSuitTiles && tile.suit !== missingSuit) {
    return { valid: false, message: '请先打缺门牌' }
  }

  return { valid: true }
}
```

---

## 7. 性能优化建议

### 7.1 代码分割
```typescript
// 路由级别懒加载
const GameBoard = lazy(() => import('./components/game/GameBoard'))

<Suspense fallback={<Loading />}>
  <GameBoard />
</Suspense>
```

### 7.2 memo化组件
```typescript
export default memo(AIPlayer, (prev, next) => {
  // 只有玩家信息变化时重新渲染
  return prev.player.id === next.player.id &&
         prev.player.handCount === next.player.handCount
})
```

### 7.3 虚拟化长列表（可选）
```typescript
// 如果历史记录很长，使用react-window
import { FixedSizeList } from 'react-window'

<FixedSizeList
  height={400}
  itemCount={discardPile.length}
  itemSize={50}
>
  {({ index, style }) => (
    <div style={style}>{discardPile[index]}</div>
  )}
</FixedSizeList>
```

---

## 8. 测试策略

### 8.1 单元测试（可选）
```typescript
// utils/tileUtils.test.ts
import { describe, it, expect } from 'vitest'
import { sortTiles } from './tileUtils'

describe('sortTiles', () => {
  it('should sort tiles by suit and rank', () => {
    const input = [
      { suit: 'tiao', rank: 5 },
      { suit: 'wan', rank: 1 },
      { suit: 'tiao', rank: 3 }
    ]
    const output = sortTiles(input)
    expect(output[0]).toEqual({ suit: 'wan', rank: 1 })
  })
})
```

---

## 9. 开发流程建议

### 9.1 Phase 1：搭建基础架构
1. 初始化Vite项目
2. 配置TypeScript、Tailwind、ESLint
3. 创建目录结构
4. 定义核心类型（Tile、GameState）
5. 搭建API服务层（apiClient、gameApi）

### 9.2 Phase 2：实现核心UI
1. 创建GameBoard容器
2. 实现PlayerHand组件（静态数据）
3. 实现DiscardPile、GameInfo
4. 接入Zustand，实现状态管理

### 9.3 Phase 3：对接后端API
1. 实现useGameState Hook（轮询）
2. 实现usePlayerAction Hook
3. 连通创建游戏、出牌流程
4. 测试前后端通信

### 9.4 Phase 4：实现Canvas渲染
1. 制作或获取麻将牌精灵图
2. 实现TileRenderer
3. 替换文字显示为Canvas渲染
4. 优化渲染性能

---

## 10. 总结

本架构设计遵循以下原则：

✅ **分层清晰**：展示、状态、逻辑、数据四层职责明确
✅ **类型安全**：TypeScript全覆盖，前后端类型共享
✅ **状态驱动**：Zustand + TanStack Query管理状态
✅ **组件化**：高内聚低耦合，可复用
✅ **性能优化**：Canvas分层、离屏缓存、按需重绘
✅ **可测试**：逻辑与UI分离，便于单元测试
✅ **可扩展**：模块化设计，易于添加新功能

该架构能够支撑MVP快速开发，同时为未来扩展（血战模式、多人对战、3D效果）预留空间。

---

**文档结束**
